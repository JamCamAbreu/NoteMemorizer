~ Topic 1: Develop Azure compute solutions (25% to 30%)

	# You should be able to...IMPLEMENT CONTAINERIZED SOLUTIONS:
		* Create and manage container images for solutions
		* Publish an image to Azure Container ^Registry
		* Run containers by using Azure Container ^Instance
		* Create solutions by using Azure Container ^Apps

	# You should be able to...IMPLEMENT AZURE APP SERVICE WEB APPS:
		* Create an Azure App Service Web App
		* Enable ^diagnostics logging
		* ^Deploy code to a web app
		* Configure web app settings including Transport Layer Security (TLS), API settings, and connection strings
		* Implement ^autoscaling

	# You should be able to...Implement Azure Functions
		* Create and configure an Azure ^Functions app
		* Implement input and output ^bindings
		* Implement function ^triggers by using data operations, timers, and webhooks


	# Which tool or service is this?
		* ^Azure ^Container ^Registry (ACR) is a managed, private Docker registry service based on the open-source Docker Registry 2.0
			- Create and maintain ^Azure ^container ^registries to store and manage your private Docker container images

	# Pull images from an Azure container registry to various deployment targets:
		* Scalable ^orchestration systems that manage containerized applications across clusters of hosts, including Kubernetes, DC/OS, and Docker Swarm.

		* ^Azure ^services that support building and running applications at scale, including Azure Kubernetes Service (AKS), App Service, Batch, Service Fabric, and others

	# Containers and CI/CD
		* Developers can target an Azure ^Container ^Registry from a continuous integration and delivery tool such as Azure Pipelines or Jenkins

	# Azure Container Registry is available in multiple service tiers
		* ^Basic: A cost-optimized entry point for developers learning about Azure Container Registry
		
		* ^Standard: increased included storage and image throughput
			- should satisfy the needs of most production scenarios
		
		* ^Premium: highest amount of included storage and concurrent operations
			- highest image throughput
			- geo replication
			- content trust for image tag signing
			- private endpoints to restrict access

	# Azure Container Registry Features
		* Azure container registries can include both Windows and ^Linux images.
		
	# Azure Container Registry Features
		* Use Azure ^Container ^Registry ^Tasks to streamline building, testing, pushing, and deploying images in Azure. 
		* Configure Azure ^Container ^Registry ^Tasks to automate your container OS and framework patching pipeline, and build images automatically when your team commits code to source control.

	# Azure Container Registry Features
		* ^Encryption-at-^rest (available at all tiers): Azure automatically encrypts an image before storing it, and decrypts it on-the-fly when you or your applications and services pull the image.

	# Azure Container Registry Features
		* ^Regional ^storage: Azure Container Registry stores data in the region where the registry is created, to help customers meet data residency and compliance requirements.
		* However, this does not guarentee availability. Customers who wish to have their registry data stored in multiple regions for better performance across different geographies or who wish to have resiliency in the event of a regional outage should enable geo-^replication.
		
	# Premium Tier - Azure Container Registry
		* ^Zone redundancy: A feature of the Premium service tier, ^zone redundancy uses Azure availability zones to replicate your registry to a minimum of three separate zones in each enabled region.

	# Azure Container Registry Features
		* Scalable ^storage: Azure Container Registry allows you to create as many repositories, images, layers, or tags as you need, up to the registry storage limit.

	# Azure Container Registries
		* ACR ^Tasks is a suite of features within Azure Container Registry.
		* It provides ^cloud-based container image building for platforms including Linux, Windows, and Azure Resource Manager, and can automate OS and framework patching for your Docker containers.
		* It enables ^automated builds triggered by source code updates, updates to a container's base image, or timers.
		
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Quick task - Build and push a single container image to a container registry on-demand, in Azure, without needing a local Docker Engine installation. Think docker build, docker push in the cloud.
		
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Automatically ^triggered tasks - Enable one or more triggers to build an image:
				- Trigger on source code update
				- Trigger on base image update
				- Trigger on a schedule
	
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Multi-step task - Extend the single image build-and-push capability of ACR Tasks with multi-step, multi-container-based workflows
		
	# Azure Container Registries "Tasks"
		* Each ACR Task has an associated source code ^context - the location of a set of source files used to build a container image or other artifact. Example contexts include a Git repository or a local filesystem.
		
	# Fill in the following Azure Container Registry question:
		* By default, ACR Tasks builds images for the ^Linux OS and the amd64 architecture. Specify the --platform tag to build Windows images or Linux images for other architectures
		
	# Fill in the following Container question:
		* A ^Dockerfile is a script that contains a series of instructions that are used to build a Docker image. ^Dockerfiles typically include the following information:
			- The base or parent image we use to create the new image
			- Commands to update the base OS and install other software
			- Build artifacts to include, such as a developed application
			- Services to expose, such a storage and network configuration
			- Command to run when the container is launched

	# Exercise: Build and run a container image by using ACR Tasks
		* Step 1: ^Create an Azure Container Registry inside a new resource group
			az group create --name myResourceGroup
											--location northcentralus
											
			az acr create --resource-group myResourceGroup
										--name brockwittrockqaacr 
										--sku Basic
						
		* Step 2: Build and push an ^image from a Docker file
			az acr build --image sample/hello-world:v1 --registry brockwittrockqaacr --file Dockerfile

		* Step 3: Verify the Results
			az acr repository --name brockwittrockaz204acr --output table

		* Step 4: ^Run the image in the ACR
			az acr run --registry brockwittrockaz204acr --cmd ‘$Registry/sample/hello-world:v1’ /dev/null

	# Which tool or service is this?
		* ^Azure ^Container ^Instances (ACI) is a great solution for any scenario that can operate in isolated containers, including simple applications, task automation, and build jobs.
			
			Benefits include:
				- Fast startup – start containers in Azure in seconds. No need to provision or manage VMs.
				- Container access – Expose your container groups directly to the internet with an IP address and an FQDN.
				- Hypervisor-level security – Completely isolate your application the same as it would be in a VM.
				- Customer data – ACI service stores the minimum customer data required to ensure your container groups are running as expected.
				- Custom sizes – You can specify custom CPU cores and memory.
				- Persistent storage – Mount Azure Files shares directly to a container to retrieve and persist state.
				- Windows and Linux- Support both operating systems using the same API.
				- Use Azure Kubernetes Service (AKS) for when you need full container orchestration including service discovery across multiple containers, automatic scaling, and coordinated application upgrades.

	# Azure Container Instance (ACI)
		* ^Container ^groups are the top-level resource in an Azure Container Instance. A collection of containers scheduled on the same host machine. Share lifecycle, resources, local network, and storage volumes. They are like a pod in Kubernetes.

	# Azure Container Instance (ACI)
		* Only ^Linux containers supported in a multi-container group. ^Windows supports a single container only

	# Azure Container Instance (ACI)
		* For deployment, use an ^ARM template or ^YAML file. 
			- ^ARM templates are more useful when you are deploying other resources alongside the container group
		
	# Answer the following question about Azure Container Instance container groups:
		* If you create a container group with two instances, each requesting one CPU, then the container group is allocated ^two (how many?) CPU(s).
		
	# Answer the following networking question about Azure Container Instance (ACI)
		* Container groups ^share an IP address and a port namespace on that IP address. 
		
		* To enable external clients to reach a container within the group, you must expose the ^port on the IP address and from the container. (Note: Because containers within the group share a port namespace, port mapping isn't supported.)
	
	# Answer the following question about using Azure Container Instance (ACI)
		* Supported ^storage volumes include Azure file share, Secret, Empty directory, and cloned git repo.
		
	# Azure Container Instance (ACI): The shell command to create a container
		* az ^container create --name mycontainer --resource-group myResourceGroup
	
	# Azure Container Instance (ACI): The shell command to create a resource group:
		* az ^group create --name myResourceGroup --location northcentralus

	# Azure Container Instances (ACI)
		Use the following command to check the status of your container:
		* az container ^show --name mycontainer --resource-group myResourceGroup --out table
		
	# The "Always" restart-policy for Azure containers 
		* The Always restart-policy ensures that containers are always restarted, regardless of the ^exit status. 
		* This policy is the default setting for container groups in Azure Container Instances, and makes sense for long-running tasks such as a web server.

	# Fill in the yaml configuration for a container instance:
		* name: securetest
			properties:
				containers:
				- name: mycontainer
					properties:
						environmentVariables:
							- name: 'NOTSECRET'
								^value: 'my-exposed-value'
							- name: 'SECRET'
								^secureValue: 'my-secret-value'
								
	# Azure Container Instances (ACI)
		* By default, Azure Container Instances are ^stateless. If the container crashes or stops, all of its ^state is lost.
			- Tip: To persist ^state beyond the lifetime of the container, you must mount a volume from an external store.
			
	# Which tool or service is this?
		* Azure ^Container ^Apps can help you deploy and manage microservices and containerized apps on a serverless platform that runs on top of Azure Kubernetes Service
		
	# Which tool or service is this?
		* Azure ^Container ^Apps provides the flexibility you need with a serverless container service built for microservice applications and robust autoscaling capabilities without the overhead of managing complex infrastructure
		
	# Common uses of Azure Container Apps include:
		* Deploying API endpoints
		* Hosting background processing applications
		* Handling event-driven processing
		* Running ^microservices
		
	# Fill in the following:
		* Applications built on Azure Container Apps can ^dynamically scale based on: HTTP traffic, event-driven processing, CPU or memory load, and any KEDA-supported scaler
		
	# With Azure Container Apps, you can:
		* Run multiple container revisions and manage the container app's application ^lifecycle.
		
		* ^Autoscale your apps based on any KEDA-supported scale trigger. Most applications can scale to zero. (Applications that scale on CPU or memory load can't scale to zero.)

	# With Azure Container Apps, you can:		
		* Enable HTTPS ^ingress without having to manage other Azure infrastructure.

		* ^Split traffic across multiple versions of an application for Blue/Green deployments and A/B testing scenarios.
		
		* Use internal ingress and service discovery for secure internal-only endpoints with built-in DNS-based service discovery.

	# With Azure Container Apps, you can:				
		* Build ^microservices with Dapr and access its rich set of APIs.

		* Run containers from any registry, public or private, including Docker Hub and Azure Container Registry (ACR).
		
		* Use the Azure CLI extension, Azure portal or ^ARM templates to manage your applications.
		
	# With Azure Container Apps, you can:					
		
		* Provide an existing ^virtual ^network when creating an environment for your container apps.
		
		* Securely manage secrets directly in your application.
		
		* Monitor logs using Azure Log Analytics.
		

	# Fill in the following question about Azure Container Apps
		* Individual container apps are deployed to a single Container Apps ^environment, which acts as a secure boundary around groups of container apps

	# Fill in the following question about Azure Container Apps
		* Container Apps in the same ^environment are deployed in the same virtual network and write logs to the same Log Analytics workspace

	# Command to install the Azure Container Apps Extension for the CLI
		* az extension add --name ^containerapp --upgrade

	# Command to create an Azure Container Apps "Environment"
		* az ^containerapp env create --name myContEnv --resource-group myGroup --location northcentralus
		
	# Creating an Azure Container App
		* By setting --ingress to ^external, you make the container app available to public requests. The command returns a link to access your app
		
	# Which tool or service is this?
		* Azure ^Container ^Apps manages the details of Kubernetes and container orchestration for you. It's containers can use any runtime, programming language, or development stack of your choice

	# Azure Container Apps
		* You can define multiple containers in a single container app to implement the ^sidecar pattern. 
			- The containers in a container app share hard disk and network resources and experience the same application lifecycle.

	# Azure Container Apps
		* You can deploy images hosted on ^private registries by providing credentials in the Container Apps configuration
		{
			...
			"registries": [{
				"server": "docker.io",
				"username": "my-registry-user-name",
				"passwordSecretRef": "my-password-secret-name"
			}]
		}

	# Limitations of Azure Container Apps
		* Azure Container Apps can't run ^privileged containers. If your program attempts to run a process that requires ^root access, the application inside the container experiences a runtime error
		
	# Limitations of Azure Container Apps
		* ^Linux-based (^linux/amd64) container images are required when using Azure Container Apps

	# Azure Container Apps Features
		* Azure Container Apps provides access to various built-in ^authentication providers.
		
		* The built-in auth features don’t require any particular language, SDK, security expertise, or even any code that you have to write.
		
		* This feature should only be used with ^HTTPS.
		
		* Ensure allowInsecure is ^disabled (enabled/disabled) on your container app's ingress configuration
	
	# Setting up Azure Container Apps authentication
		* To restrict app access only to authenticated users, set its Restrict access setting to ^Require ^authentication.
		
		* To authenticate but not restrict access, set its Restrict access setting to ^Allow ^unauthenticated access.
	
	# Setting up Azure Container Apps authentication
		* The authentication and authorization ^middleware component is a feature of the platform that runs as a sidecar ^container on each replica in your application. 
		
		* When enabled, every incoming HTTP request passes through the security layer before being handled by your application.

	# Setting up Azure Container Apps authentication
	
		* The authentication flow is the same for all providers, but differs depending on whether you want to sign in with the provider's SDK:

			Without provider SDK (^server-directed flow or ^server flow): The application delegates federated sign-in to Container Apps. Delegation is typically the case with ^browser apps, which presents the provider's sign-in page to the user.

			With provider SDK (^client-directed flow or ^client flow): The application signs users in to the provider manually and then submits the authentication token to Container Apps for validation. This approach is typical for browser-less apps that don't present the provider's sign-in page to the user. An example is a native ^mobile app that signs users in using the provider's SDK.

	# Azure Container Apps
		* Azure Container Apps implements container app versioning by creating ^revisions
		* A ^revision is an immutable snapshot of a container app version. 
		* You can use ^revisions to release a new version of your app, or quickly revert to an earlier version of your app
		
	# Azure Container Apps
		* You can control which ^revisions are active, and the external traffic that is routed to each active ^revision. ^Revision names are used to identify a ^revision, and in the ^revision's URL. You can customize the ^revision name by setting the ^revision suffix
		
	# Azure Container Apps
		* With the " az containerapp ^update " command you can modify environment variables, compute resources, scale parameters, and deploy a different image. 
		* If your container app update includes revision-scope changes, a new revision is generated.

	# Azure Container Apps
		* You can list all revisions associated with your container app with the " az containerapp revision ^list " command

	# Azure Container Apps allows your application to securely store sensitive configuration values. 
		
		* Once ^secrets are defined at the application level, secured values are available to container apps. 
		
		* ^Secrets are scoped to an application, outside of any specific revision of an application.

	# Azure Container Apps and Configuration

		* Adding, removing, or changing secrets doesn't generate new ^revisions.

		* Each application ^revision can reference one or more secrets.
		
		* Multiple ^revisions can reference the same secret(s).

	# Azure Container Apps and Configuration
		* Before you delete a ^secret, deploy a new revision that no longer references the old ^secret. 
		
		* Then deactivate all revisions that reference the ^secret.

	# Azure Container Apps
		* Container Apps doesn't support Azure ^Key ^Vault integration. 
		
		* Instead, enable managed identity in the container app and use the ^Key ^Vault SDK in your ^app to access secrets.

	# Distributed Application Runtime (Dapr) 
		* ...is a set of incrementally adoptable features that simplify the authoring of distributed, ^microservice-based applications.

	# Distributed Application Runtime (Dapr) 
		* Dapr provides capabilities for enabling application intercommunication through messaging via ^pub/^sub or reliable and secure service-to-service calls.

	# Dapr is an open source, Cloud Native Computing Foundation (CNCF) project. The CNCF is part of the Linux Foundation and provides support, oversight, and direction for fast-growing, cloud native projects. As an alternative to deploying and managing the Dapr OSS project yourself, the Container Apps platform:

		* Provides a managed and supported Dapr integration
		
		* Handles Dapr ^version upgrades seamlessly
		
		* Exposes a simplified Dapr interaction model to increase developer productivity

	# You can configure Dapr using various arguments and annotations based on the runtime context. 
	  Azure Container Apps provides three channels through which you can configure Dapr:

		* Container Apps CLI
		
		* Infrastructure as Code (IaC) ^templates, as in Bicep or Azure Resource Manager (ARM) ^templates
		
		* The Azure portal

	# Distributed Application Runtime (Dapr) 
		* Dapr uses a modular design where functionality is delivered as a ^component. 
		* The use of Dapr ^components is optional and dictated exclusively by the needs of your application.

	# What is a revision in Azure Container Apps? 
		* An immutable ^snapshot of a container app version


	# Which tool or service is this?
		* Azure ^App ^Service is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends. You can develop in your favorite programming language or framework. Applications run and scale with ease on both Windows and Linux-based environments.

	# Azure App Service Features
		* Includes build-in auto ^scale support
		* ^Scale up/down (vertical; resources) or out/in (horizontal; machines)
		
	# Azure App Service Features
		* The Azure portal provides out-of-the-box ^continuous ^integration and deployment with Azure DevOps Services, GitHub, Bitbucket, FTP, or a local Git repository on your development machine

	# Azure App Service Features
		* When you deploy your web app you can use a separate ^deployment ^slot instead of the default production ^slot when you're running in the Standard App Service Plan tier or better

	# Azure App Service Deployment Slots
		* Deployment slots are live apps with their own ^host names
		
		* App content and ^configuration elements can be swapped between two deployment slots, including the production slot

	# Azure App Service for Linux
		* App Service can also host web apps natively on Linux for supported application stacks. 
		
		* It can also run custom Linux containers (also known as ^Web ^App for Containers)
		
		* App Service on Linux isn't supported on ^Shared pricing tier.
	
	# Azure App Service
		* In App Service, an app always runs in an App Service ^plan. 
		
		* An App Service ^plan defines a set of compute resources for a web app to run. 
		
		* One or more apps can be configured to run on the same computing resources (or in the same App Service ^plan).
	
	# Each App Service plan defines:
		* Operating System (Windows, Linux)
		* Region (West US, East US, etc.)
		* Number of ^VM instances
		* Size of ^VM instances (Small, Medium, Large)
		* Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)
	
	
	# Azure App Service Plan Pricing Tiers
		* ^Shared compute: Free and Shared, the two base tiers, runs an app on the same Azure VM as other App Service apps, including apps of other customers. These tiers allocate CPU quotas to each app that runs on the shared resources, and the resources ^can't (can/cannot) scale out.

		* Dedicated compute

		* Isolated
		
	# Azure App Service Plan Pricing Tiers
		* Shared compute

		* Dedicated^ compute: The Basic, Standard, Premium, PremiumV2, and PremiumV3 tiers run apps on dedicated Azure VMs. Only apps in the same App Service ^plan share the same compute resources. The higher the tier, the more VM instances are available to you for scale-out.

		* Isolated
		
	# Azure App Service Plan Pricing Tiers
		* Shared compute

		* Dedicated compute

		* ^Isolated: The ^Isolated and ^IsolatedV2 tiers run dedicated Azure VMs on dedicated Azure Virtual Networks. It provides ^network isolation on top of compute isolation to your apps. It provides the maximum scale-out capabilities.

	# Azure App Service Plan
		* In the ^Free and ^Shared tiers, an app receives CPU minutes on a shared VM instance and can't scale out.

	# Azure App Service Plan
		* If the plan is configured for autoscaling, then ^all apps in the plan are scaled out together based on the autoscale settings.

	# Azure APp Service Plan
		* Your App Service plan can be scaled up and down at any time. It's as simple as changing the ^pricing ^tier of the plan

	# Azure App Service Deployments
		* Azure supports ^automated deployment directly from several sources. The following options are available:
			* Azure DevOps Services: You can push your code to Azure DevOps Services, build your code in the cloud, run the tests, generate a release from the code, and finally, push your code to an Azure Web App.
			
			* GitHub: Azure supports automated deployment directly from GitHub. When you connect your GitHub repository to Azure for automated deployment, any changes you push to your production branch on GitHub are automatically deployed for you.
			
			* Bitbucket: With its similarities to GitHub, you can configure an automated deployment with Bitbucket.

	# Azure App Service Deployments
		* Here are some options for ^manual deployment of your app:

			* Git: App Service web apps feature a Git URL that you can add as a remote repository. Pushing to the remote repository deploys your app.
			
			* CLI: webapp up is a feature of the az command-line interface that packages your app and deploys it. Unlike other deployment methods, az webapp up can create a new App Service web app for you if you haven't already created one.
			
			* Zip deploy: Use curl or a similar HTTP utility to send a ZIP of your application files to App Service.
			
			* FTP/S: FTP or FTPS is a traditional way of pushing your code to many hosting environments, including App Service.

	# Azure App Service Deployments
		* Whenever possible, use deployment ^slots when deploying a new production build. 
		
		* When using a Standard App Service Plan tier or better, you can deploy your app to a staging environment and then swap your staging and production ^slots.


	# Azure App Service Security
		* Azure App Service provides built-in ^authentication and ^authorization support, so you can sign in users and access data by writing minimal, or no code in your web app, RESTful API, mobile back end, and Azure Functions

		* You're not required to use App Service for ^authentication and ^authorization. Many web frameworks are bundled with security features, and you can use them if you like.

		* You can integrate with multiple login providers. For example, Microsoft Entra ID, Facebook, Google, Twitter.

	# Azure App Service Security
		* App Service uses ^federated identity, in which a third-party identity provider manages the user identities and authentication flow for you.
		
		* Examples include Microsoft Identity Platform, Facebook, Google, Twitter, Any OpenID Connect provider, and Github

		* You can provide your users with any number of these sign-in options.

	# Azure App Service - Built in Authentication and Authorization Module
		* The authentication and authorization module runs in the same ^sandbox as your application code. 
		
		* When it's enabled, every incoming HTTP request passes through it before being handled by your application code.

		* The module can be configured using Azure ^Resource ^Manager settings or using a configuration file

	# Azure App Service - Authorization Behaviors
		* Allow ^unauthenticated requests: This option defers authorization of unauthenticated traffic to your application code. For authenticated requests, App Service also passes along authentication information in the HTTP headers. This option provides more flexibility in handling anonymous requests. It lets you present multiple sign-in providers to your users.

	# Azure App Service - Authorization Behaviors
		* ^Require authentication: This option rejects any unauthenticated traffic to your application. This rejection can be a redirect action to one of the configured identity providers. In these cases, a browser client is redirected to /.auth/login/<provider> for the provider you choose. If the anonymous request comes from a native mobile app, the returned response is an HTTP 401 Unauthorized. You can also configure the rejection to be an HTTP 401 Unauthorized or HTTP 403 Forbidden for all requests.

	# Azure App Service Features
		* App Service provides a built-in ^token ^store, which is a repository of tokens that are associated with the users of your web apps, APIs, or native mobile apps. 
		
		* When you enable authentication with any provider, this ^token ^store is immediately available to your app.

	# Azure App Service Features
		* If you enable application logging, authentication and authorization traces are collected directly in your ^log files. 
		* If you see an authentication error that you didn't expect, you can conveniently find all the details by looking in your existing application logs.

	# Azure App Service Networking
		* Azure App Service is a distributed system. The roles that handle incoming HTTP or HTTPS requests are called ^front ^ends. 
		* The roles that host the customer workload are called ^workers. All the roles in an App Service deployment exist in a multi-tenant network

	# Azure App Service Networking
		* By default, apps hosted in App Service are accessible directly through the ^internet and can reach only ^internet-hosted endpoints.


	# Azure App Service Networking
		* All the roles in an App Service deployment exist in a ^multi-tenant network. Because there are many different customers in the same App Service scale unit, you can't connect the App Service network directly to your network.
		
		* Instead of connecting the networks, you need features to handle the various aspects of application communication.

	# Azure App Service Networking
		* Azure App Service scale units support many customers in each deployment. 
			* The ^Free and ^Shared SKU plans host customer workloads on multitenant workers. 
			* The ^Basic and higher plans host customer workloads that are dedicated to only one App Service plan

	# Azure App Service Networking
		* If you have a ^Standard App Service plan, all the apps in that plan run on the same worker. 
		* If you scale out the worker, all the apps in that App Service plan are replicated on a new worker for each instance in your App Service plan.

	# Azure App Service Networking
		* The outbound addresses used by your app for making outbound calls are listed in the ^properties for your app. These addresses are shared by all the apps running on the same worker VM family in the App Service deployment.
		
		


~ Topic 2: Develop for Azure storage (15% to 20%)

	# You should be able to...DEVELOP SOLUTIONS THAT USE AZURE COSMOS DB
		* Perform operations on containers and items by using the ^SDK
		* Set the appropriate ^consistency level for operations
		* Implement ^change ^feed notifications

	# You should be able to...DEVELOP SOLUTIONS THAT USE AZURE BLOB STORAGE
		* Set and retrieve ^properties and metadata
		* Perform operations on data by using the appropriate SDK
		* Implement storage ^policies and data ^lifecycle management
		* Implement ^static website hosting


	# BLOB stands for:
		* ^Binary
		* ^Large
		* ^OBject

	# Azure Blob storage is Microsoft's object storage solution for the cloud. 
		* Blob storage is optimized for storing massive amounts of ^unstructured data. 
		* ^Unstructured data is data that doesn't adhere to a particular data model or definition, such as text or binary data

	# Blob storage is designed for:
		* Serving images or documents directly to a browser
		* Storing files for ^distributed access
		* ^Streaming video and audio
		* Writing to log files
		* Storing data for ^backup and restore, disaster recovery, and archiving
		* Storing data for ^analysis by an on-premises or Azure-hosted service

	# Users or client applications can access objects in Blob storage via HTTP/HTTPS, from anywhere in the world. 
		* Objects in Blob storage are accessible via: 
			- the Azure Storage ^REST API
			- Azure ^PowerShell
			- Azure CLI
			- an Azure Storage client library

	# Blob Storage Accounts: Performance Tiers
		* ^Standard: This is the general-purpose v2 account and is recommended for most scenarios using Azure Storage

		* ^Premium: offer higher performance by using solid-state drives. 
			Additionally, you can choose between three account types: 
				- block blobs
				- page blobs 
				- file shares

	# Access Tiers for Blob Storage:
		* The ^Hot access tier
			- optimized for FREQUENT access of objects in the storage account
			- Highest storage costs, but the lowest access costs
			- New storage accounts are created in this tier by default

		* The ^Cool access tier
			- optimized for storing large amounts of data that is infrequently accessed and stored for at least 30 days
			- Lower storage costs and higher access costs

		* The ^Cold access tier
			- optimized for storing data that is INFREQUENTLY accessed and stored for a minimum of 90 days. 
			- has lower storage costs and higher access costs compared to the cool tier.

		* The ^Archive tier
			- optimized for data that can tolerate several hours of retrieval latency and remains in the tier for at least 180 days
			- the most cost-effective option for storing data
			- however, ACCESSING that data is more expensive

	





~ Topic 3: Implement Azure security (20% to 25%)

	# You should be able to...IMPLEMENT USER AUTHENTICATION AND AUTHORIZATION
		* Authenticate and authorize users by using the Microsoft ^Identity platform
		* Authenticate and authorize users and apps by using Microsoft ^Entra ^ID
		* Create and implement ^shared ^access signatures
		* Implement solutions that interact with Microsoft ^Graph

	# You should be able to...IMPLEMENT SECURE AZURE SOLUTIONS
		* Secure app configuration data by using App ^Configuration or Azure ^Key ^Vault
		* Develop code that uses keys, secrets, and ^certificates stored in Azure Key Vault
		* Implement ^Managed ^Identities for Azure resources

	# Authorization vs Authentication
		* ^Authentication - confirm that users are who they say they are.

	# Authorization vs Authentication
		* ^Authorization - gives those users permission to access a resource.
		
	# When you register your application with Microsoft Entra ID, you're creating an identity configuration for your application that allows it to integrate with Microsoft Entra ID. 
	
		When you register an app in the Azure portal, you choose whether it is:
		* ^Single-^tenant: only accessible in your tenant
		* ^Multi-^tenant: accessible in other tenants
		
	# If you register an application in the portal...
		* ...an ^application object (the globally unique instance of the app) and a ^service ^principal object are automatically created in your home tenant
		
		* You also have a globally unique ID for your app (the app or ^client ID)
		
		* In the portal, you can then add secrets or certificates and scopes to make your app work, customize the branding of your app in the sign-in dialog, and more.
		
	# You can also create service principal objects in a tenant using 
		* Azure ^PowerShell, 
		* Azure ^CLI, 
		* Microsoft Graph
		* ...and other tools
		
	# A Microsoft Entra application is defined by its one and only application object. 
		* The application object resides in the Microsoft Entra ^tenant where the application was registered (known as the application's "home" ^tenant)
		
		* An application object is used as a template or blueprint to create one or more ^service ^principal objects
		
		* A service principal is created in every ^tenant where the application is used
		
		* Similar to a class in object-oriented programming, the application object has some ^static properties that are applied to all the created service principals (or application instances).
		
	# The "application object" describes three aspects of an application:
		* How the service can issue ^tokens in order to access the application
		* ^Resources that the application might need to access
		* The ^actions that the application can take

	# To access resources secured by a Microsoft Entra tenant, the entity that requires access must be represented by a security principal. 
		* This is true for both users (^user principal) and applications (^service principal).

	# The security principal defines the...
		* ... ^access policy and permissions for the user/application in the Microsoft Entra tenant.
		* This enables core features such as authentication of the user/application during sign-in, and authorization during resource access.

	# There are three types of SERVICE PRINCIPLES
		* Application Service Principle: this type of service principal is the local representation, or ^application ^instance of a global application object in a single ^tenant or directory
		
	# There are three types of SERVICE PRINCIPLES
		* ^Managed Identity: ^Managed identities provide an identity for applications to use when connecting to resources that support Microsoft Entra authentication
		
	# There are three types of SERVICE PRINCIPLES
		* ^Legacy: this type of service principal represents a ^legacy app
		* ^legacy apps are apps created before app registrations were introduced
		
	# Relationship between application objects and service principals
		* The application object is the ^global representation of your application for use across all tenants, and the service principal is the ^local representation for use in a specific tenant.
		
		* The application object serves as the ^template from which common and default properties are derived for use in creating corresponding service principal objects.
		
	# An application object has:
		* A one to ^one_ relationship with the software application
		* A one to ^many relationships with its corresponding service principal object(s).
		
	# The Microsoft identity platform implements the ... 
		* ^OAuth 2.0 authorization protocol
		* ^OAuth 2.0 is a method through which a third-party app can access web-hosted resources on behalf of a user. 
		* Any web-hosted resource that integrates with the Microsoft identity platform has a resource identifier, or *application ID URI. I.e. "https://graph.microsoft.com", "https://outlook.office.com", etc...
		
	# When a resource's functionality is chunked into small permission sets, third-party apps can be built to request only the permissions that they need to perform their function. Users and administrators can know what data the app can access.
		* In OAuth 2.0, these types of permission sets are called ^scopes. They're also often referred to as permissions. 
		* In the Microsoft identity platform, a permission is represented as a string value.
		
	# Authentication and Authorization: PERMISSION TYPES
		* ^delegated: used by apps that have a signed-in user present. For these apps, either the user or an administrator consents to the permissions that the app requests
		
		* ^app-^only access: used to run apps without a signed in user (i.e. background services or daemons). Only an administrator can consent to ^app-^only access permissions.
		
	# Authentication and Authorization: CONSENT TYPES
		* ^static user consent
		* ^incremental and dynamic user consent
		* ^admin consent
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Static ^user consent: You must specify all the permissions it would ever need up front (Difficult and often overwhelming to user)
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Incremental and Dynamic: Ability to requent permissions ^incrementally instead of all up front. You can ask for a minimum set of permissions upfront and request more over time as the customer uses more app features
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Admin: ^Admin consent ensures that administrators have some other controls before authorizing apps or users to access highly privileged data from the organization.

	# Fill in the following AUTHENTICATION question:
		* The ^Conditional ^Access feature in Microsoft Entra ID offers one of several ways that you can use to secure your app and protect a service:
			- Multifactor authentication
			- Allowing only Intune (cloud-based service for managing mobile devices and computers) to access specific services
			- Restricting user locations and IP ranges

	# Components that make up the Microsoft identity platform:
		* ^OAuth 2.0 and ^OpenID Connect standard-compliant authentication service enabling developers to authenticate several identity types, including:
			- Work or school accounts, provisioned through Microsoft Entra ID
			- Personal Microsoft account, like Skype, Xbox, and Outlook.com
			- Social or local accounts, by using Azure Active Directory B2C
			- Social or local customer accounts, by using Microsoft Entra External ID

	# Components that make up the Microsoft identity platform:
		* ^Open-^source libraries: Microsoft Authentication Libraries (MSAL) and support for other standards-compliant libraries
		
		* Microsoft identity platform ^endpoint: works with a variety of standards-compliant libraries. It implements human readable scopes, in accordance with industry standards.
	
	# Components that make up the Microsoft identity platform:
		* Application ^management portal: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities.
		
		* Application ^configuration API and PowerShell: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks.

	# Fill in the following AUTHENTICATION question:
		* A ^shared ^access ^signature (SAS) is a URI that grants restricted access rights to Azure Storage resources. 
		* You can provide a ^shared ^access ^signature to clients that you want to grant delegate access to certain storage account resources.

	# Types of Shared Access Signatures:
		Tip: A shared access signature (SAS) is a URI that grants restricted access rights to Azure Storage resources
		
		* ^User ^delegation SAS: secured with Microsoft Entra credentials and also by the permissions specified for the SAS. 
			- Applies to Blob storage only
			
		* ^Service SAS: 
			- secured with the storage account key. 
			- delegates access to a resource in the following Azure Storage services: Blob storage, Queue storage, Table storage, or Azure Files.
			
		* ^Account SAS: 
			- Secured with the storage account key. 
			- Delegates access to resources in one or more of the storage services. 
			- All of the operations available via the other SAS types are also available

	# When to use a Shared Access Signature (SAS)
		* When you want to provide secure access to resources in your ^storage account to any client who doesn't otherwise have permissions to those resources

	# Which tool or service is this?
		* Microsoft ^Graph is the gateway to data and intelligence in Microsoft 365. It provides a unified programmability model that you can use to access the tremendous amount of data in Microsoft 365, Windows 10, and Enterprise Mobility and includes  security features






~ Topic 4: Monitor, troubleshoot, and optimize Azure solutions (15% to 20%)

	# You should be able to...IMPLEMENT CACHING FOR SOLUTIONS
		* Configure cache and ^expiration policies for Azure Cache for Redis
		* Implement secure and optimized application cache ^patterns including data sizing, connections, encryption, and expiration
		* Implement Azure ^Content ^Delivery ^Network endpoints and profiles

	# You should be able to...TROUBLESHOOT SOLUTIONS BY USING APPLICATION INSIGHTS
		* Configure an app or service to use Application Insights
		* Monitor and analyze metrics, logs, and ^traces
		* Implement Application Insights ^web ^tests and ^alerts


	# You can utilize Redis on your own machine as a service or on the cloud. 
		* The default port used for redis is port ^6379

	# Redis is not used for long term storage...
		* All data in Redis exists in ^memory

	# Redis has a very simple structure
		* ^json strings
		* "Key": "Value"
		
	# Which tool can you use to interact with a Redis Cache instance manually?
		* The ^redis-cli allows you to enter commands and interact with a Redis Cache instance manually

	# Which Redis command sets a key called "points" to the value "12"?
		* ^SET points 12
		
	# What does the following Redis command do? 
		"lrange MyList 0 -1"
		* This command returns ALL of values of the ^list called MyList
	
	# Explain the following Redis command:
		"setex MyPassword 2400 dwarfFortress12$"
		* This command sets the ^key called MyPassword and it's ^value to dwarfFortress12$. 
		* Then, that keyvalue pair will ^expire after 2400 ^seconds
	
	# Which command in Redis is responsible for checking to see if a keyvalue pair exists?
		* "^EXISTS myKey"
		
	# Microsoft recommends using the following pattern when working with caches like Redis Cache
		* The ^Cache-^Aside pattern
		
	#  Storing too much in a cookie can have a negative effect on performance as the cookie size grows and is passed and validated with every request.
		* A typical solution uses the ^cookie as a KEY to query the data in a database
		* Using an ^in-^memory cache, like Azure Cache for Redis, to associate information with a user is faster than interacting with a full relational database.
		* This is often called the ^Session ^Store pattern

	# Applications sometimes require a series of commands against a backend data-store to execute as a single atomic operation
		* Single atomic operation means that all commands MUST succeed, or all must be rolled back to the initial state
		* Azure Cache for Redis supports executing a ^batch of commands as a single transaction
		
	# Basic tier for Redis cache runs on a single VM. 
		* This tier has no ^service-^level ^agreement and is ideal for ^development/^test and noncritical workloads
		
	# In general, when choosing Redis Cache tiers, The higher up the tiers you go you get access to higher ^throughput, lower ^latency, better ^availability and more ^features
		
	# Fill in the following:
		* A ^content ^delivery ^network is a distributed network of servers that can efficiently deliver web content to users
		* They store cached content on edge servers in ^point-of-^presence (POP) locations that are close to end users, to minimize latency.
		
	# Features of Azure CDN (Content Delivery Networks):
		* Large scaling, less traffic to origin servers
		* CDN ^Caching rules
		* ^HTTPS support: Azure CDN can host a TLS/SSL certification or you can use your own. 
			Note: Using ^HTTPS does not increase the cost of Azure CDN.
		* Azure diagnostics logs
		* File compression / object ^chunking
		
	# Features of Azure CDN (Content Delivery Networks):
		* Geo-^filtering enables you to allow or block content in specific countries/regions.
		* Azure CDN can also accelerate dynamic content, which can't be cached, by using various network optimizations using CDN POPs.
		* Pre-populate caching in CDNs by using “ az cdn endpoint ^load ”
		* Purge content from your CDNs by using “” or using the PurgeContent method in the Microsoft.Azure.Management.Cdn library in an app implementation.

	# How Azure CDN Functions
		* 1. User requests endpoint, DNS routes request to closest ^POP location
		* 2. If no edge servers have the requested content in their cache, ^POP requests the file from the ^origin server.
				 Note: “^origin server” here can mean an Azure Web App, or any publicly accessible web server.
		* 3. Origin server returns file to edge server in ^POP location
		* 4. Edge server in ^POP location caches file and returns it to user. ^Time-to-^live (TTL) is specified by the origin server in the HTTP header (Cache-Control), or default to 7 days.

	# When setting Caching Rules, Azure CDN's support two kinds of match conditions:
		* Path^ match condition: This condition matches the path of the URL, excluding domain name, and supports the wildcard symbol
			For example, /myfile.html, /my/folder/*, and /my/images/*.jpg
		
		* Extension^ match condition: Provide a list of comma delimited file extensions to match.
			For example, .jpg, .mp3, .png

	# Azure CDN Caching Rules Priority:
		* If no rules are defined, the ^default caching behavior is used (HTTP cache-directive header)
		* If ^global caching rules exist, they overwrite any default caching behavior
		* If ^custom caching rules exist, they overwrite any other behavior

	# "Fresh" content (Azure CDN concepts)
		*  A cached resource is considered to be fresh when its ^age is less than the that defined by a cache setting
		* Therefore if your content is time-sensitive and you need to ensure accurate updates to the content, then make sure to set your ^time-to-^live to a short duration, or consider including a version string in the asset URL.

	# Azure CDNs (Content Delivery Networks) Use Object Chunking
		* When a ^large file is requested, the CDN prefetches smaller 8MB chunks of the content in parallel, serving the user the chunks as they are recieved and caching those chunks for repeated requests.
		* This prefetch process ensures that the content stays one chunk ahead of the user, which reduces latency. 

	# Collections of Azure CDN (Content Delivery Network) endpoints is called:
		* A CDN ^profile
		* A ^profile defines the pricing tier for that collection of endpoints
		* You can only have so many ^profiles in one azure subscription









~ Topic 5: Connect to and consume Azure services and third-party services (15% to 20%)

	# You should be able to...IMPLEMENT API MANAGEMENT
		* Create an Azure API Management instance
		* Create and ^document APIs
		* Configure access to APIs
		* Implement ^policies for APIs

	# You should be able to...DEVELOP EVENT-BASED SOLUTIONS
		* Implement solutions that use Azure Event ^Grid
		* Implement solutions that use Azure Event ^Hub

	# You should be able to...DEVELOP MESSAGE-BASED SOLUTIONS
		* Implement solutions that use Azure ^Service ^Bus
		* Implement solutions that use Azure ^Queue ^Storage queues
		
		
	# Which service is this?
		* Azure ^Event ^Grid is a serverless event broker you can use to integrate applications using events.
		
	# Benefits of using Azure Event Grid:
		* Simplify event consumption
		
		* Lower costs by eliminating the need for constant polling
		
		* Efficiently and reliably routes events from Azure as well as non-Azure resources and distributes the events to registered subscriber endpoints
		
	# Event Grid - Events
		* Smallest amount of information describing something that happened in the system
		* There is information common to all events (source, date and time, and unique ID) as well as information unique to the event
		* The General Availability (GA) SLA allows events up to 64 KB in size. Support for events up to 1MB in size is currently in preview
		* Events over 64 KB are charged in 64 KB increments
		
	# Event Grid - Event Sources
		* Where the event happened
		* Responsible for sending (i.e. publishing) events to Event Grid
		
	# Event Grid - Topics
		* Provides the endpoints where an event source sends events
		* Used for a collection of related events
		* A source can specify one or more topics
		* System topics are built-in topics provided by Azure services
			- You cannot see these in your Azure subscription, but you can subscribe to them by providing information about the resource you want to recieve events from (e.g. Blob Storage)
		* Custom topics are application and third-party topics
		* Subscribers decide which topics to subscribe to in order to respond to certain types of events
		
	# Event Grid - Subscriptions
		* Tell Event Grid which events on a topic you're interested in receiving
		* As a subscriber you provide the endpoint that will recieve (i.e. handle) the events
		* Optional filters can be supplied to filter events by event type or subject pattern
		* Subscriptions can be created with expiration date
		
	# Event Grid - Event Handlers
		* The destination to where an event is sent
		* Takes further action to process the events it receives
		* There are different types of event handlers including supported Azure services (?) or custom webhooks
		* Event Grid has different logic in place to guarantee the delivery of an event for the different types of handlers
		
	# Event Grid - Event Schemas
		* 2 Types: Event Grid event schema and Cloud event schema
		* All events consists of 4 required string properties: subject, eventType, eventTime, and id
		* The data object has properties specific to the publisher
		* Event sources sent events to Event Grid in an array consisting of one or more event objects
			* Each object can be up to 1MB in size, but the total size of the array itself cannot exceed 1 MB
		* 
		
	# Event Grid - Subject Tips
		* Consider providing the path for where events happened so subscribers can filter and route events by segments of the path
		* For example if you have a 3-segment path /A/B/C a user can choose to filter by any part of the path depending on whether they want the broad set of events (filtering on /A) or a narrower set of events (filtering on /A/B/C) or something in between (filtering on /A/B)
		
	# Event Grid - Cloud Event Schema
		* CloudEvents is an open specification for describing event data
		* Natively supported by Azure
		*
		
	# Event Grid - Delivery Durability
		* Event Grid attempts to deliver each event at least once for each matching subscription immediately
		* If the event the subscriber does not acknowledge receipt of an event or if there's a failure, Event Grid retries delivery accordingly to a fixed retry schedule and policy
		* By default, Event Grid delivers 1 event at a time to a subscriber via an array of consisting of just that 1 event
		* Event Grid does NOT guarantee order of event delivery
		
	# Event Grid - Retry Schedule
		* When Event Grid receives an error for an attempted event delivery it chooses one of the following options based on the type of error:
			- Retry the delivery
			- Dead-letter the event (optional configuration)
			- Drop the event
			
		* After 30 seconds from point of attempted delivery, if an endpoint hasn't responded, the message is queued for retry
		* If the endpoint responds within 3 minutes, Event Grid attempts to remove the event from the retry queue on a best effort basis (i.e. you might get duplicates)
		* The following endpoint errors will not produce retry attempts by Event Grid:
			- Azure Resources: 400 Bad Request, 413 Request Entity Too Large, 403 Forbidden
			- Webhook: 400, 413, 403, 404 Not Found, 401 Unauthorized
			
	# Event Grid - Retry Policy
		* You can customize the retry policy, but only when creating the subscription
			- Maximum # of Attempts: A value between 1 and 30. Default is 30.
			- Event TTL (time to live): A value between 1 and 1440. Default is 1440.
			
	# Event Grid - Output Batching
		* You can configure Event Grid to batch events for delivery to improve HTTP performance
		* Batching is turned off by default
		* 2 Settings:
			- Max Events / Batch - A value between 1 and 5000
			- Preferred Batch Size in KB - Batches that exceed this configured size will still be delivered
			
	# Event Grid - Delayed Delivery
		* As an endpoint experience delivery failures, Event Grid will begin to delay the delivery and retry of events to the endpoint
		* The purpose is to protect unhealthy endpoints and the Event Grid system itself by reducing unnecessary retries that could potentially overwhelm systems
		
	# Event Grid - Dead Letter Events
		* AN optional process where Event Grid sends undeliverable events to a storage account
		* EventGrid dead-letters an event when either of the following conditions are met:
			- Event isn't delivered within the time-to-live period
			- The number of retries exceeds the limit
		* Dead lettering is off by default
		* Configurable at the subscription creation time. The storage account location is where you can pull the undelivered events to resolve the delivery
		* There is a 5 minute delay between the last attempt to deliver and event and the delivery of that event to the dead letter location
		* In the event the dead letter location is unavailable for 4 hours, the event is dropped
		
	# Event Grid - Custom Delivery Properties
		* Event subscriptions allow HTTP headers that are included in delivered events
		* Useful for when a destination requires custom headers
		* Can set up to 10 custom headers when creating the event subscription with each header not exceeding 4,096 bytes
		* Can set the custom headers on events delivered to the following destinations:
			* Webhooks
			* Azure Service Bus Topics
			* Azure Event Hubs
			* Relay Hybrid Connections
			
	# Event Grid - Access Controls:
		* Role																	Description
		* Event Grid Subscription Reader 				Lets you read Event Grid event subscriptions
		* Event Grid Subscription Contributor		Lets you manage Event Grid event subscription operations
		* Event Grid Contributor								Lets you create and manage Event Grid resources
		* Event Grid Data Sender								Lets you send events to Event Grid topics
		
		* If you are using an event handler that isn't a webhook, you need write access to that resource. The permission will differ based on whether the subscription is for a system or custom topic
	
	
	# Event Grid - Using Webhooks
		* Event Grid requires you to prove ownership of your Webhook endpoint before it will start delivering ends to that endpoint
		* This validation is handled automatically when using the following 3 Azure Services:
			* Azure Logic Apps with Event Grid Connector
			* Azure Automation via Webhook
			* Azure Functions with Event Grid Trigger
			
		* 2 Ways to validate a subscription
			* Synchronous Handshake: Happens at the time of event subscription creation. An event is sent from EventGrid to your endpoint that includes a validationCode property that your app must verify the request by responding with the same validationCode. Newer versions also support a manual validation method using a validationUrl and GET request. The URL is valid for 5 minutes.
			
			* Asynchronous Handshake: Specifically for cases where you can't erturn the ValidationCode using the synchronous handshake. This is often the case when using third-party services (e.g. Zapier)
			
			
	# Event Gird - Filtering
		* 3 Filtering Options
			* Event Types
			* Subject "Begins With" or "End With"
			* Advanced Fields and Operators
				* Operator Type - the type of comparison
				* Key - the field (number, Boolean, or string) in the vent data you're using for filtering
				* Value(s) - the value(s) to compare to the key
				
				
	# Azure Event Hub
		* Big data streaming platform and event ingestion service
		* Lives between event publishers and event consumers
		
	# Event Hubs - Key Features:
		* Fully managed PaaS solution: Essentially Apache Kafka under the hood, but the clusters are managed by Microsoft
		* Real-time and batch processing - allows concurrent processing of the event stream as well as allows you to control the speed of the event processing
		* Capture event data - Capture data to Azure Blob Storage or Azure data lake storage
		* Scalable
		* Rich ecosystem - any Apache Kafka compatible clients can talk to Event Hubs
		
	# Event Hubs - Key Concepts
		* Event Hubs Client - The interface for developers to interact with the Event Hubs client library
		* Event Hubs Producer - a type of client that is a source/publisher of log data
		* Event Hubs Consumer - A type of client that is the consumer of log data. Often have built-in analytics (e.g. Microsoft Stream Analytics)
		* Partitions - an ordered sequence of events stored in an Event Hub. A way to provide parallel consumption of events. Number of partitions in an Event Hub specified at creation time.
		* Consumer Group - a veiw of an entire Event Hubs. Specific to each client consumer of the event stream.
		* Event Recievers - 
		TODO
		
	# Event Hubs - Capture
		* Specify whether the data is stored in an Azure Blob Storage account and container or an Azure Data Lake Store account
		* Captured data is written in the Apache Avro binary format (compatible with Hadoop, Stream Analytics, and Azure Data Factory)
		* You specify a retention period so over time and older data is automatically removed and Event Hubs remains at a manageable size
		* You set up a minimum size and time (i.e., window) with a "first wins policy"
		* Each partition captures independently to the specified destination in the following format:
			{Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}
			
			*Note: this means that one message could end up in multiple partitions
			
	# Event Hubs - Throughput Units
		* Event Hubs traffic controlled by throughput units
		* A single throughput unit allows 1 MB/second or 1000 events per second of ingress and twice that for egress
		* Standard SKU allows 1~20 throughput units which a quota increase via a support request
		* Usage beyond your purchase limit IS throttled by Azure
		* Egress only applies when utilizing other processing readers such as Stream Analytics or Spark
		* Once configured, Event Hubs runs automatically when you send your first event and continues to run
		* Even if there is no incoming data, Event Hubs still writes empty files to let you know it's still working as expected
		
	# Ingress vs Egress
		* Ingress: messages coming into the system
		* Egress: messages being sent out of the system
		
	# Event Hubs - Scale Process Application
		* To scale your event processing application, you can run multiple instances of the application and have it balance the load among themselves
		* For the .NET and Java SDK use Event 