~ Topic 1: Develop Azure compute solutions (25% to 30%)

	# You should be able to...IMPLEMENT CONTAINERIZED SOLUTIONS:
		* Create and manage container images for solutions
		* Publish an image to Azure Container ^Registry
		* Run containers by using Azure Container ^Instance
		* Create solutions by using Azure Container ^Apps

	# You should be able to...IMPLEMENT AZURE APP SERVICE WEB APPS:
		* Create an Azure App Service Web App
		* Enable ^diagnostics logging
		* ^Deploy code to a web app
		* Configure web app settings including Transport Layer Security (TLS), API settings, and connection strings
		* Implement ^autoscaling

	# You should be able to...Implement Azure Functions
		* Create and configure an Azure ^Functions app
		* Implement input and output ^bindings
		* Implement function ^triggers by using data operations, timers, and webhooks


	# Which tool or service is this?
		* ^Azure ^Container ^Registry (ACR) is a managed, private Docker registry service based on the open-source Docker Registry 2.0
			- Create and maintain ^Azure ^container ^registries to store and manage your private Docker container images

	# Pull images from an Azure container registry to various deployment targets:
		* Scalable ^orchestration systems that manage containerized applications across clusters of hosts, including Kubernetes, DC/OS, and Docker Swarm.

		* ^Azure ^services that support building and running applications at scale, including Azure Kubernetes Service (AKS), App Service, Batch, Service Fabric, and others

	# Containers and CI/CD
		* Developers can target an Azure ^Container ^Registry from a continuous integration and delivery tool such as Azure Pipelines or Jenkins

	# Azure Container Registry is available in multiple service tiers
		* ^Basic: A cost-optimized entry point for developers learning about Azure Container Registry
		
		* ^Standard: increased included storage and image throughput
			- should satisfy the needs of most production scenarios
		
		* ^Premium: highest amount of included storage and concurrent operations
			- highest image throughput
			- geo replication
			- content trust for image tag signing
			- private endpoints to restrict access

	# Azure Container Registry Features
		* Azure container registries can include both Windows and ^Linux images.
		
	# Azure Container Registry Features
		* Use Azure ^Container ^Registry ^Tasks to streamline building, testing, pushing, and deploying images in Azure. 
		* Configure Azure ^Container ^Registry ^Tasks to automate your container OS and framework patching pipeline, and build images automatically when your team commits code to source control.

	# Azure Container Registry Features
		* ^Encryption-at-^rest (available at all tiers): Azure automatically encrypts an image before storing it, and decrypts it on-the-fly when you or your applications and services pull the image.

	# Azure Container Registry Features
		* ^Regional ^storage: Azure Container Registry stores data in the region where the registry is created, to help customers meet data residency and compliance requirements.
		* However, this does not guarentee availability. Customers who wish to have their registry data stored in multiple regions for better performance across different geographies or who wish to have resiliency in the event of a regional outage should enable geo-^replication.
		
	# Premium Tier - Azure Container Registry
		* ^Zone redundancy: A feature of the Premium service tier, ^zone redundancy uses Azure availability zones to replicate your registry to a minimum of three separate zones in each enabled region.

	# Azure Container Registry Features
		* Scalable ^storage: Azure Container Registry allows you to create as many repositories, images, layers, or tags as you need, up to the registry storage limit.

	# Azure Container Registries
		* ACR ^Tasks is a suite of features within Azure Container Registry.
		* It provides ^cloud-based container image building for platforms including Linux, Windows, and Azure Resource Manager, and can automate OS and framework patching for your Docker containers.
		* It enables ^automated builds triggered by source code updates, updates to a container's base image, or timers.
		
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Quick task - Build and push a single container image to a container registry on-demand, in Azure, without needing a local Docker Engine installation. Think docker build, docker push in the cloud.
		
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Automatically ^triggered tasks - Enable one or more triggers to build an image:
				- Trigger on source code update
				- Trigger on base image update
				- Trigger on a schedule
	
	# ACR "Tasks" supports several scenarios to build and maintain container images and other artifacts
		* ^Multi-step task - Extend the single image build-and-push capability of ACR Tasks with multi-step, multi-container-based workflows
		
	# Azure Container Registries "Tasks"
		* Each ACR Task has an associated source code ^context - the location of a set of source files used to build a container image or other artifact. Example contexts include a Git repository or a local filesystem.
		
	# Fill in the following Azure Container Registry question:
		* By default, ACR Tasks builds images for the ^Linux OS and the amd64 architecture. Specify the --platform tag to build Windows images or Linux images for other architectures
		
	# Fill in the following Container question:
		* A ^Dockerfile is a script that contains a series of instructions that are used to build a Docker image. ^Dockerfiles typically include the following information:
			- The base or parent image we use to create the new image
			- Commands to update the base OS and install other software
			- Build artifacts to include, such as a developed application
			- Services to expose, such a storage and network configuration
			- Command to run when the container is launched

	# Exercise: Build and run a container image by using ACR Tasks
		* Step 1: ^Create an Azure Container Registry inside a new resource group
			az group create --name myResourceGroup
											--location northcentralus
											
			az acr create --resource-group myResourceGroup
										--name brockwittrockqaacr 
										--sku Basic
						
		* Step 2: Build and push an ^image from a Docker file
			az acr build --image sample/hello-world:v1 --registry brockwittrockqaacr --file Dockerfile

		* Step 3: Verify the Results
			az acr repository --name brockwittrockaz204acr --output table

		* Step 4: ^Run the image in the ACR
			az acr run --registry brockwittrockaz204acr --cmd ‘$Registry/sample/hello-world:v1’ /dev/null

	# Which tool or service is this?
		* ^Azure ^Container ^Instances (ACI) is a great solution for any scenario that can operate in isolated containers, including simple applications, task automation, and build jobs.
			
			Benefits include:
				- Fast startup – start containers in Azure in seconds. No need to provision or manage VMs.
				- Container access – Expose your container groups directly to the internet with an IP address and an FQDN.
				- Hypervisor-level security – Completely isolate your application the same as it would be in a VM.
				- Customer data – ACI service stores the minimum customer data required to ensure your container groups are running as expected.
				- Custom sizes – You can specify custom CPU cores and memory.
				- Persistent storage – Mount Azure Files shares directly to a container to retrieve and persist state.
				- Windows and Linux- Support both operating systems using the same API.
				- Use Azure Kubernetes Service (AKS) for when you need full container orchestration including service discovery across multiple containers, automatic scaling, and coordinated application upgrades.

	# Azure Container Instance (ACI)
		* ^Container ^groups are the top-level resource in an Azure Container Instance. A collection of containers scheduled on the same host machine. Share lifecycle, resources, local network, and storage volumes. They are like a pod in Kubernetes.

	# Azure Container Instance (ACI)
		* Only ^Linux containers supported in a multi-container group. ^Windows supports a single container only

	# Azure Container Instance (ACI)
		* For deployment, use an ^ARM template or ^YAML file. 
			- ^ARM templates are more useful when you are deploying other resources alongside the container group
		
	# Answer the following question about Azure Container Instance container groups:
		* If you create a container group with two instances, each requesting one CPU, then the container group is allocated ^two (how many?) CPU(s).
		
	# Answer the following networking question about Azure Container Instance (ACI)
		* Container groups ^share an IP address and a port namespace on that IP address. 
		
		* To enable external clients to reach a container within the group, you must expose the ^port on the IP address and from the container. (Note: Because containers within the group share a port namespace, port mapping isn't supported.)
	
	# Answer the following question about using Azure Container Instance (ACI)
		* Supported ^storage volumes include Azure file share, Secret, Empty directory, and cloned git repo.
		
	# Azure Container Instance (ACI): The shell command to create a container
		* az ^container create --name mycontainer --resource-group myResourceGroup
	
	# Azure Container Instance (ACI): The shell command to create a resource group:
		* az ^group create --name myResourceGroup --location northcentralus

	# Azure Container Instances (ACI)
		Use the following command to check the status of your container:
		* az container ^show --name mycontainer --resource-group myResourceGroup --out table
		
	# The "Always" restart-policy for Azure containers 
		* The Always restart-policy ensures that containers are always restarted, regardless of the ^exit status. 
		* This policy is the default setting for container groups in Azure Container Instances, and makes sense for long-running tasks such as a web server.

	# Fill in the yaml configuration for a container instance:
		* name: securetest
			properties:
				containers:
				- name: mycontainer
					properties:
						environmentVariables:
							- name: 'NOTSECRET'
								^value: 'my-exposed-value'
							- name: 'SECRET'
								^secureValue: 'my-secret-value'
								
	# Azure Container Instances (ACI)
		* By default, Azure Container Instances are ^stateless. If the container crashes or stops, all of its ^state is lost.
			- Tip: To persist ^state beyond the lifetime of the container, you must mount a volume from an external store.
			
	# Which tool or service is this?
		* Azure ^Container ^Apps can help you deploy and manage microservices and containerized apps on a serverless platform that runs on top of Azure Kubernetes Service
		
	# Which tool or service is this?
		* Azure ^Container ^Apps provides the flexibility you need with a serverless container service built for microservice applications and robust autoscaling capabilities without the overhead of managing complex infrastructure
		
	# Common uses of Azure Container Apps include:
		* Deploying API endpoints
		* Hosting background processing applications
		* Handling event-driven processing
		* Running ^microservices
		
	# Fill in the following:
		* Applications built on Azure Container Apps can ^dynamically scale based on: HTTP traffic, event-driven processing, CPU or memory load, and any KEDA-supported scaler
		
	# With Azure Container Apps, you can:
		* Run multiple container revisions and manage the container app's application ^lifecycle.
		
		* ^Autoscale your apps based on any KEDA-supported scale trigger. Most applications can scale to zero. (Applications that scale on CPU or memory load can't scale to zero.)

	# With Azure Container Apps, you can:		
		* Enable HTTPS ^ingress without having to manage other Azure infrastructure.

		* ^Split traffic across multiple versions of an application for Blue/Green deployments and A/B testing scenarios.
		
		* Use internal ingress and service discovery for secure internal-only endpoints with built-in DNS-based service discovery.

	# With Azure Container Apps, you can:				
		* Build ^microservices with Dapr and access its rich set of APIs.

		* Run containers from any registry, public or private, including Docker Hub and Azure Container Registry (ACR).
		
		* Use the Azure CLI extension, Azure portal or ^ARM templates to manage your applications.
		
	# With Azure Container Apps, you can:					
		
		* Provide an existing ^virtual ^network when creating an environment for your container apps.
		
		* Securely manage secrets directly in your application.
		
		* Monitor logs using Azure Log Analytics.
		

	# Fill in the following question about Azure Container Apps
		* Individual container apps are deployed to a single Container Apps ^environment, which acts as a secure boundary around groups of container apps

	# Fill in the following question about Azure Container Apps
		* Container Apps in the same ^environment are deployed in the same virtual network and write logs to the same Log Analytics workspace

	# Command to install the Azure Container Apps Extension for the CLI
		* az extension add --name ^containerapp --upgrade

	# Command to create an Azure Container Apps "Environment"
		* az ^containerapp env create --name myContEnv --resource-group myGroup --location northcentralus
		
	# Creating an Azure Container App
		* By setting --ingress to ^external, you make the container app available to public requests. The command returns a link to access your app
		
	# Which tool or service is this?
		* Azure ^Container ^Apps manages the details of Kubernetes and container orchestration for you. It's containers can use any runtime, programming language, or development stack of your choice

	# Azure Container Apps
		* You can define multiple containers in a single container app to implement the ^sidecar pattern. 
			- The containers in a container app share hard disk and network resources and experience the same application lifecycle.

	# Azure Container Apps
		* You can deploy images hosted on ^private registries by providing credentials in the Container Apps configuration
		{
			...
			"registries": [{
				"server": "docker.io",
				"username": "my-registry-user-name",
				"passwordSecretRef": "my-password-secret-name"
			}]
		}

	# Limitations of Azure Container Apps
		* Azure Container Apps can't run ^privileged containers. If your program attempts to run a process that requires ^root access, the application inside the container experiences a runtime error
		
	# Limitations of Azure Container Apps
		* ^Linux-based (^linux/amd64) container images are required when using Azure Container Apps

	# Azure Container Apps Features
		* Azure Container Apps provides access to various built-in ^authentication providers.
		
		* The built-in auth features don’t require any particular language, SDK, security expertise, or even any code that you have to write.
		
		* This feature should only be used with ^HTTPS.
		
		* Ensure allowInsecure is ^disabled (enabled/disabled) on your container app's ingress configuration
	
	# Setting up Azure Container Apps authentication
		* To restrict app access only to authenticated users, set its Restrict access setting to ^Require ^authentication.
		
		* To authenticate but not restrict access, set its Restrict access setting to ^Allow ^unauthenticated access.
	
	# Setting up Azure Container Apps authentication
		* The authentication and authorization ^middleware component is a feature of the platform that runs as a sidecar ^container on each replica in your application. 
		
		* When enabled, every incoming HTTP request passes through the security layer before being handled by your application.

	# Setting up Azure Container Apps authentication
	
		* The authentication flow is the same for all providers, but differs depending on whether you want to sign in with the provider's SDK:

			Without provider SDK (^server-directed flow or ^server flow): The application delegates federated sign-in to Container Apps. Delegation is typically the case with ^browser apps, which presents the provider's sign-in page to the user.

			With provider SDK (^client-directed flow or ^client flow): The application signs users in to the provider manually and then submits the authentication token to Container Apps for validation. This approach is typical for browser-less apps that don't present the provider's sign-in page to the user. An example is a native ^mobile app that signs users in using the provider's SDK.

	# Azure Container Apps
		* Azure Container Apps implements container app versioning by creating ^revisions
		* A ^revision is an immutable snapshot of a container app version. 
		* You can use ^revisions to release a new version of your app, or quickly revert to an earlier version of your app
		
	# Azure Container Apps
		* You can control which ^revisions are active, and the external traffic that is routed to each active ^revision. ^Revision names are used to identify a ^revision, and in the ^revision's URL. You can customize the ^revision name by setting the ^revision suffix
		
	# Azure Container Apps
		* With the " az containerapp ^update " command you can modify environment variables, compute resources, scale parameters, and deploy a different image. 
		* If your container app update includes revision-scope changes, a new revision is generated.

	# Azure Container Apps
		* You can list all revisions associated with your container app with the " az containerapp revision ^list " command

	# Azure Container Apps allows your application to securely store sensitive configuration values. 
		
		* Once ^secrets are defined at the application level, secured values are available to container apps. 
		
		* ^Secrets are scoped to an application, outside of any specific revision of an application.

	# Azure Container Apps and Configuration

		* Adding, removing, or changing secrets doesn't generate new ^revisions.

		* Each application ^revision can reference one or more secrets.
		
		* Multiple ^revisions can reference the same secret(s).

	# Azure Container Apps and Configuration
		* Before you delete a ^secret, deploy a new revision that no longer references the old ^secret. 
		
		* Then deactivate all revisions that reference the ^secret.

	# Azure Container Apps
		* Container Apps doesn't support Azure ^Key ^Vault integration. 
		
		* Instead, enable managed identity in the container app and use the ^Key ^Vault SDK in your ^app to access secrets.

	# Distributed Application Runtime (Dapr) 
		* ...is a set of incrementally adoptable features that simplify the authoring of distributed, ^microservice-based applications.

	# Distributed Application Runtime (Dapr) 
		* Dapr provides capabilities for enabling application intercommunication through messaging via ^pub/^sub or reliable and secure service-to-service calls.

	# Dapr is an open source, Cloud Native Computing Foundation (CNCF) project. The CNCF is part of the Linux Foundation and provides support, oversight, and direction for fast-growing, cloud native projects. As an alternative to deploying and managing the Dapr OSS project yourself, the Container Apps platform:

		* Provides a managed and supported Dapr integration
		
		* Handles Dapr ^version upgrades seamlessly
		
		* Exposes a simplified Dapr interaction model to increase developer productivity

	# You can configure Dapr using various arguments and annotations based on the runtime context. 
	  Azure Container Apps provides three channels through which you can configure Dapr:

		* Container Apps CLI
		
		* Infrastructure as Code (IaC) ^templates, as in Bicep or Azure Resource Manager (ARM) ^templates
		
		* The Azure portal

	# Distributed Application Runtime (Dapr) 
		* Dapr uses a modular design where functionality is delivered as a ^component. 
		* The use of Dapr ^components is optional and dictated exclusively by the needs of your application.

	# What is a revision in Azure Container Apps? 
		* An immutable ^snapshot of a container app version


	# Which tool or service is this?
		* Azure ^App ^Service is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends. You can develop in your favorite programming language or framework. Applications run and scale with ease on both Windows and Linux-based environments.

	# Azure App Service Features
		* Includes build-in auto ^scale support
		* ^Scale up/down (vertical; resources) or out/in (horizontal; machines)
		
	# Azure App Service Features
		* The Azure portal provides out-of-the-box ^continuous ^integration and deployment with Azure DevOps Services, GitHub, Bitbucket, FTP, or a local Git repository on your development machine

	# Azure App Service Features
		* When you deploy your web app you can use a separate ^deployment ^slot instead of the default production ^slot when you're running in the Standard App Service Plan tier or better

	# Azure App Service Deployment Slots
		* Deployment slots are live apps with their own ^host names
		
		* App content and ^configuration elements can be swapped between two deployment slots, including the production slot

	# Azure App Service for Linux
		* App Service can also host web apps natively on Linux for supported application stacks. 
		
		* It can also run custom Linux containers (also known as ^Web ^App for Containers)
		
		* App Service on Linux isn't supported on ^Shared pricing tier.
	
	# Azure App Service
		* In App Service, an app always runs in an App Service ^plan. 
		
		* An App Service ^plan defines a set of compute resources for a web app to run. 
		
		* One or more apps can be configured to run on the same computing resources (or in the same App Service ^plan).
	
	# Each App Service plan defines:
		* Operating System (Windows, Linux)
		* Region (West US, East US, etc.)
		* Number of ^VM instances
		* Size of ^VM instances (Small, Medium, Large)
		* Pricing tier (Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3, Isolated, IsolatedV2)
	
	
	# Azure App Service Plan Pricing Tiers
		* ^Shared compute: Free and Shared, the two base tiers, runs an app on the same Azure VM as other App Service apps, including apps of other customers. These tiers allocate CPU quotas to each app that runs on the shared resources, and the resources ^can't (can/cannot) scale out.

		* Dedicated compute

		* Isolated
		
	# Azure App Service Plan Pricing Tiers
		* Shared compute

		* Dedicated^ compute: The Basic, Standard, Premium, PremiumV2, and PremiumV3 tiers run apps on dedicated Azure VMs. Only apps in the same App Service ^plan share the same compute resources. The higher the tier, the more VM instances are available to you for scale-out.

		* Isolated
		
	# Azure App Service Plan Pricing Tiers
		* Shared compute

		* Dedicated compute

		* ^Isolated: The ^Isolated and ^IsolatedV2 tiers run dedicated Azure VMs on dedicated Azure Virtual Networks. It provides ^network isolation on top of compute isolation to your apps. It provides the maximum scale-out capabilities.

	# Azure App Service Plan
		* In the ^Free and ^Shared tiers, an app receives CPU minutes on a shared VM instance and can't scale out.

	# Azure App Service Plan
		* If the plan is configured for autoscaling, then ^all apps in the plan are scaled out together based on the autoscale settings.

	# Azure APp Service Plan
		* Your App Service plan can be scaled up and down at any time. It's as simple as changing the ^pricing ^tier of the plan

	# Azure App Service Deployments
		* Azure supports ^automated deployment directly from several sources. The following options are available:
			* Azure DevOps Services: You can push your code to Azure DevOps Services, build your code in the cloud, run the tests, generate a release from the code, and finally, push your code to an Azure Web App.
			
			* GitHub: Azure supports automated deployment directly from GitHub. When you connect your GitHub repository to Azure for automated deployment, any changes you push to your production branch on GitHub are automatically deployed for you.
			
			* Bitbucket: With its similarities to GitHub, you can configure an automated deployment with Bitbucket.

	# Azure App Service Deployments
		* Here are some options for ^manual deployment of your app:

			* Git: App Service web apps feature a Git URL that you can add as a remote repository. Pushing to the remote repository deploys your app.
			
			* CLI: webapp up is a feature of the az command-line interface that packages your app and deploys it. Unlike other deployment methods, az webapp up can create a new App Service web app for you if you haven't already created one.
			
			* Zip deploy: Use curl or a similar HTTP utility to send a ZIP of your application files to App Service.
			
			* FTP/S: FTP or FTPS is a traditional way of pushing your code to many hosting environments, including App Service.

	# Azure App Service Deployments
		* Whenever possible, use deployment ^slots when deploying a new production build. 
		
		* When using a Standard App Service Plan tier or better, you can deploy your app to a staging environment and then swap your staging and production ^slots.


	# Azure App Service Security
		* Azure App Service provides built-in ^authentication and ^authorization support, so you can sign in users and access data by writing minimal, or no code in your web app, RESTful API, mobile back end, and Azure Functions

		* You're not required to use App Service for ^authentication and ^authorization. Many web frameworks are bundled with security features, and you can use them if you like.

		* You can integrate with multiple login providers. For example, Microsoft Entra ID, Facebook, Google, Twitter.

	# Azure App Service Security
		* App Service uses ^federated identity, in which a third-party identity provider manages the user identities and authentication flow for you.
		
		* Examples include Microsoft Identity Platform, Facebook, Google, Twitter, Any OpenID Connect provider, and Github

		* You can provide your users with any number of these sign-in options.

	# Azure App Service - Built in Authentication and Authorization Module
		* The authentication and authorization module runs in the same ^sandbox as your application code. 
		
		* When it's enabled, every incoming HTTP request passes through it before being handled by your application code.

		* The module can be configured using Azure ^Resource ^Manager settings or using a configuration file

	# Azure App Service - Authorization Behaviors
		* Allow ^unauthenticated requests: This option defers authorization of unauthenticated traffic to your application code. For authenticated requests, App Service also passes along authentication information in the HTTP headers. This option provides more flexibility in handling anonymous requests. It lets you present multiple sign-in providers to your users.

	# Azure App Service - Authorization Behaviors
		* ^Require authentication: This option rejects any unauthenticated traffic to your application. This rejection can be a redirect action to one of the configured identity providers. In these cases, a browser client is redirected to /.auth/login/<provider> for the provider you choose. If the anonymous request comes from a native mobile app, the returned response is an HTTP 401 Unauthorized. You can also configure the rejection to be an HTTP 401 Unauthorized or HTTP 403 Forbidden for all requests.

	# Azure App Service Features
		* App Service provides a built-in ^token ^store, which is a repository of tokens that are associated with the users of your web apps, APIs, or native mobile apps. 
		
		* When you enable authentication with any provider, this ^token ^store is immediately available to your app.

	# Azure App Service Features
		* If you enable application logging, authentication and authorization traces are collected directly in your ^log files. 
		* If you see an authentication error that you didn't expect, you can conveniently find all the details by looking in your existing application logs.

	# Azure App Service Networking
		* Azure App Service is a distributed system. The roles that handle incoming HTTP or HTTPS requests are called ^front ^ends. 
		* The roles that host the customer workload are called ^workers. All the roles in an App Service deployment exist in a multi-tenant network

	# Azure App Service Networking
		* By default, apps hosted in App Service are accessible directly through the ^internet and can reach only ^internet-hosted endpoints.


	# Azure App Service Networking
		* All the roles in an App Service deployment exist in a ^multi-tenant network. Because there are many different customers in the same App Service scale unit, you can't connect the App Service network directly to your network.
		
		* Instead of connecting the networks, you need features to handle the various aspects of application communication.

	# Azure App Service Networking
		* Azure App Service scale units support many customers in each deployment. 
			* The ^Free and ^Shared SKU plans host customer workloads on multitenant workers. 
			* The ^Basic and higher plans host customer workloads that are dedicated to only one App Service plan

	# Azure App Service Networking
		* If you have a ^Standard App Service plan, all the apps in that plan run on the same worker. 
		* If you scale out the worker, all the apps in that App Service plan are replicated on a new worker for each instance in your App Service plan.

	# Azure App Service Networking
		* The outbound addresses used by your app for making outbound calls are listed in the ^properties for your app. These addresses are shared by all the apps running on the same worker VM family in the App Service deployment.
		
	# What is Azure Functions?
	  * Azure Functions is a ^serverless solution that allows you to build robust apps while using less code, and with less infrastructure and lower costs.

	# A ^trigger defines how an Azure function is invoked, and a function must have exactly one ^trigger.

	# In Azure Functions, ^Binding to a function is a way of declaratively connecting your functions to other resources.

	# Which hosting option for Azure Functions provides fully serverless execution where you only pay for execution time?
	  * The ^Consumption plan

	# What is the purpose of using input and output ^bindings in Azure Functions?
	  * ^Bindings either pass data into your function (an input ^binding) or enable you to write data out from your function (an output ^binding) by using ^binding parameters.

	# Azure Functions
	  * Functions integrates directly with Visual Studio, Visual Studio Code, Maven, and other popular development tools to enable seamless ^debugging and deployments

	# Deploying Azure Functions
	  * Deploy by using your favorite client tool: Visual Studio Code, Visual Studio, or from the command line using Azure Functions Core Tools or the Azure ^CLI.
	
	# In Azure Functions, what allows you to avoid hardcoding access to other services?
	  * ^Triggers and ^bindings let you avoid hardcoding access to other services.

	# In Azure Functions, Which hosting option for Azure Functions keeps instances always-warm for the fastest response times?
	  *  " ^Event-driven scaling " hosting options range from fully serverless, where you only pay for execution time (Consumption plan), to always-warm instances kept ready for the fastest response times (Premium plan).

	# Question 3: How does autoscale handle scale-out when multiple rules are triggered?
	  * If more than one scale-out rule is triggered, autoscale scales to the ^highest specified capacity to ensure service availability."

	# When scale-out rules are triggered, autoscale calculates the new capacity determined by the ^scaleAction specified for each of its rules. 

	# When is the ^default profile used in autoscale?
	  * The ^default profile runs when there are no other applicable profiles for the current date and time
	  * The ^default profile instance count needs to fall within the Minimum and Maximum instance limits

	# What is the ^cooldown period in autoscale?
	  * This period is the amount of time to wait after a scale operation before scaling again. 
	  * The ^cooldown period allows the metrics to stabilize and avoids scaling more than once for the same condition.

	# Calculating thresholds in App Service Autoscale rules
	  * For percentage based thresholds such as memory usage and CPU usage, the ^average usage of all instances of the app is used to determine if a threshold is reached

	# You plan to create an Azure Functions app named app1.
	  You need to ensure that app1 will satisfy the following requirements:
		* Supports automatic scaling.
		* Has event-based scaling behavior.
		* Provides a serverless pricing model.

	  Which hosting plan should you use?
	  * Use the ^Consumption hosting plan

	# Azure Functions Apps
	  * The ^fan - ^out / ^fan - ^in pattern enables multiple functions to be executed in parallel, waiting for all functions to finish. 
	  * Often, some aggregation work is done on the results that are returned from the functions. 

	# Azure Function Apps
	  * Using the ^dynamicThrottlesEnabled property allows developers to let the system respond dynamically to an increased utilization, returning “429 Too Busy” errors. 
	  * This property is defined in the host.json file. The bindings section, part of the function.json file, is used to define the bindings and triggers for a function.

	# You need to delete an image with the tag dev/nginx:latest from an Azure container registry named devregistry.
	  Use the following command:

	  * az acr ^repository delete --name devregistry --image dev/nginx:latest

	# Azure Container Instances Vs Apps
	  * Azure Container ^Apps enables you to build serverless microservices based on containers. It is optimized for running general purpose containers and provides many application-specific concepts on top of containers.
	  * Azure Container ^Instances does not support scaling, load balancing, revisions, scale, or environments.

	# You develop a web application hosted on the Web Apps feature of Microsoft Azure App Service.
	  You need to enable and configure Azure Web Service Local Cache with 1.5 GB.
	  Which two code segments should you use? Each correct answer presents part of the solution.

	  * “WEBSITE_LOCAL_CACHE_SIZEINMB”: “1500”
	  * “WEBSITE_LOCAL_CACHE_OPTION”: ^“Always”

	# You develop an App Service app hosted on Windows Platform. Users report that the app is failing.
	  You need to begin troubleshooting the app by inspecting a copy of the page that is returned when the HTTP return code is greater than 400.
	  Which type of log should you review?

	  * ^detailed ^error log
	  * The ^detailed ^error log contains copies of the error pages, produced in response to HTTP codes greater than 400, that would have been sent to clients. These pages are not sent due to security reasons.

	# Purchasing an App Service certificate automates the process of requesting, ^renewing, and synchronizing the certificate with the App Service apps that use them



~ Topic 2: Develop for Azure storage (15% to 20%)

	# You should be able to...DEVELOP SOLUTIONS THAT USE AZURE COSMOS DB
		* Perform operations on containers and items by using the ^SDK
		* Set the appropriate ^consistency level for operations
		* Implement ^change ^feed notifications

	# You should be able to...DEVELOP SOLUTIONS THAT USE AZURE BLOB STORAGE
		* Set and retrieve ^properties and metadata
		* Perform operations on data by using the appropriate SDK
		* Implement storage ^policies and data lifecycle management
		* Implement ^static website hosting


	# BLOB stands for:
		* ^Binary
		* ^Large
		* ^OBject

	# Azure Blob storage is Microsoft's object storage solution for the cloud. 
		* Blob storage is optimized for storing massive amounts of ^unstructured data. 
		* ^Unstructured data is data that doesn't adhere to a particular data model or definition, such as text or binary data

	# Blob storage is designed for:
		* Serving images or documents directly to a browser
		* Storing files for ^distributed access
		* ^Streaming video and audio
		* Writing to log files
		* Storing data for ^backup and restore, disaster recovery, and archiving
		* Storing data for analysis by an on-premises or Azure-hosted service

	# Users or client applications can access objects in Blob storage via HTTP/HTTPS, from anywhere in the world. 
		* Objects in Blob storage are accessible via: 
			- the Azure Storage ^REST API
			- Azure ^PowerShell
			- Azure CLI
			- an Azure Storage client library

	# Blob Storage Accounts: Performance Tiers
		* ^Standard: This is the general-purpose v2 account and is recommended for most scenarios using Azure Storage

		* ^Premium: offer higher performance by using solid-state drives. 
			Additionally, you can choose between three account types: 
				- block blobs
				- page blobs 
				- file shares

	# Access Tiers for Blob Storage:
		* The ^Hot access tier
			- optimized for FREQUENT access of objects in the storage account
			- Highest storage costs, but the lowest access costs
			- New storage accounts are created in this tier by default

		* The ^Cool access tier
			- optimized for storing large amounts of data that is infrequently accessed and stored for at least 30 days
			- Lower storage costs and higher access costs

		* The ^Cold access tier
			- optimized for storing data that is INFREQUENTLY accessed and stored for a minimum of 90 days. 
			- has lower storage costs and higher access costs compared to the cool tier.

		* The ^Archive tier
			- optimized for data that can tolerate several hours of retrieval latency and remains in the tier for at least 180 days
			- the most cost-effective option for storing data
			- however, ACCESSING that data is more expensive
	
	# Which command in the Azure Cosmos DB .NET SDK is used to create a new item in a container?
		* Use the ^CreateItemAsync method of the Container class to create a new item in a container.

	# Which property must be unique within a logical partition for each item in Azure Cosmos DB?
		* The ^id property is a unique string that is user-settable and must not exceed 255 characters.

	# In Azure Cosmos DB, what is the hierarchical resource model starting from the top level?
		* An Azure Cosmos DB ^account is a container for databases
		* Each ^database is a container for containers
		* Each ^container is a container for items.

	# Which consistency level in Azure Cosmos DB ensures that reads never see uncommitted or partial writes?
		* The ^Strong consistency level guarantees that reads are consistent with the last write acknowledged by the service.

	# Scalability in Azure Cosmos DB
		* The ^partition key determines how data is distributed across physical ^partitions in a container. 
		* It enables efficient scalability by allowing Cosmos DB to distribute data and queries across multiple servers, optimizing performance for large-scale workloads.

	# How can you query items in a Cosmos DB container using the SQL API?
		* Use the ^QueryItemsAsync method of the Container class in the .NET SDK, passing a SQL query string or a QueryDefinition object to retrieve items matching the query criteria.

	# What is the primary unit of scalability and throughput allocation in Azure Cosmos DB for a container or database?
		* Azure Cosmos DB uses ^Request ^Units (RUs) as the currency for throughput, representing the cost of read and write operations.

	# Which API in Azure Cosmos DB is optimized for storing and querying JSON documents with a schema-free structure?
		* The ^Core (SQL) API provides a SQL-like query language for querying JSON documents in a schema-free manner.

	# The blob service is the only Storage Account type that supports ^user delegation shared access signatures.
	  * A Shared Access Signature (SAS) is a URI that includes a token granting restricted access to specific Azure resources (e.g., a blob, container, file, queue, or table). 
	  * Why only Blob Service?: Blob Storage supports Azure ^Active ^Directory integration for fine-grained Role-Based Access Control (RBAC)
	  
	# A ^Shared ^Access ^Signature (SAS) is a URI that includes a token granting restricted access to specific Azure resources (e.g., a blob, container, file, queue, or table). 
	  * The ^token in the URI specifies the permissions, resource scope, and validity period, and it is signed with a key to ensure security. 
	  * SAS allows you to share access to Azure resources without exposing your account’s primary or secondary access keys.

	# Various type of Shared Access Signatures (SAS):
	  * ^User Delegation SAS (Supported only by Blob Service) is signed with a ^user delegation key, which is derived from an Azure Active Directory (Azure AD) identity (user or managed identity) rather than an account key.

	  * A "Service" SAS is signed with the storage account key, granting access to a specific resource (e.g., a single blob, file, queue, or table).

	  * An "Account" SAS signed with the storage account key, granting access to MULTIPLE resources or services within a storage account. (emphasis on a broader permission scope than service SAS, including access to service-level operations (e.g., listing containers).)

	# Various type of Shared Access Signatures (SAS):
	  * "User Delegation" SAS (Supported only by Blob Service) is signed with a ^user delegation key, which is derived from an Azure Active Directory (Azure AD) identity (user or managed identity) rather than an account key.

	  * A ^Service SAS is signed with the storage account key, granting access to a specific resource (e.g., a single blob, file, queue, or table).

	  * An "Account" SAS signed with the storage account key, granting access to MULTIPLE resources or services within a storage account. (emphasis on a broader permission scope than service SAS, including access to service-level operations (e.g., listing containers).)

	# Various type of Shared Access Signatures (SAS):
	  * "User Delegation" SAS (Supported only by Blob Service) is signed with a ^user delegation key, which is derived from an Azure Active Directory (Azure AD) identity (user or managed identity) rather than an account key.

	  * A "Service" SAS is signed with the storage account key, granting access to a specific resource (e.g., a single blob, file, queue, or table).

	  * An ^Account SAS signed with the storage account key, granting access to MULTIPLE resources or services within a storage account. (emphasis on a broader permission scope than service SAS, including access to service-level operations (e.g., listing containers).)

	# Microsoft Entra ID
	  * OAuth 2.0 ^On - ^Behalf - ^Of flow (OBO) is used when an application invokes a service or web API, which in turn needs to call another service or web API. 
	  * The idea is to propagate the delegated user identity and permissions through the request chain.

	# In the following shared access signature token code, the 'b' stands for ^blob, and it can also be set to 'c' which stands for ^container

		BlobSasBuilder sasBuilder = new BlobSasBuilder()
		{
		  BlobContainerName = containerClient.Name,
		  Resource = "b"
		};

		sasBuilder.ExpiresOn = DateTimeOffset.UtcNow.AddHours(1);
		sasBuilder.SetPermissions(BlobContainerSasPermissions.Read);
		Uri sasUri = containerClient.GenerateSasUri(sasBuilder);

	# Cosmos DB Consistency levels:
	  * ^Strong: Ensures all reads reflect the most recent committed writes, with transactional updates ^immediately visible together across all replicas.  
	  * Bounded Staleness: Reads lag behind writes by a set amount, but transactional updates are visible together within a defined lag.  
	  * Session: Guarantees transactional updates are visible together within a single client session.  
	  * Consistent Prefix: Ensures reads see updates in order, with transactional updates visible as a consistent sequence.  
	  * Eventual: Updates in a transaction are applied together but may not be visible immediately due to eventual propagation across replicas.

	# Cosmos DB Consistency levels:
	  * Strong: Ensures all reads reflect the most recent committed writes, with transactional updates immediately visible together across all replicas.  
	  * ^Bounded ^Staleness: Reads lag behind writes by a set amount, but transactional updates are visible together within a defined ^lag.  
	  * Session: Guarantees transactional updates are visible together within a single client session.  
	  * Consistent Prefix: Ensures reads see updates in order, with transactional updates visible as a consistent sequence.  
	  * Eventual: Updates in a transaction are applied together but may not be visible immediately due to eventual propagation across replicas.

	# Cosmos DB Consistency levels:
	  * Strong: Ensures all reads reflect the most recent committed writes, with transactional updates immediately visible together across all replicas.  
	  * Bounded Staleness: Reads lag behind writes by a set amount, but transactional updates are visible together within a defined lag.  
	  * ^Session: Guarantees transactional updates are visible together within a single client ^session.  
	  * Consistent Prefix: Ensures reads see updates in order, with transactional updates visible as a consistent sequence.  
	  * Eventual: Updates in a transaction are applied together but may not be visible immediately due to eventual propagation across replicas.

	# Cosmos DB Consistency levels:
	  * Strong: Ensures all reads reflect the most recent committed writes, with transactional updates immediately visible together across all replicas.  
	  * Bounded Staleness: Reads lag behind writes by a set amount, but transactional updates are visible together within a defined lag.  
	  * Session: Guarantees transactional updates are visible together within a single client session.  
	  * ^Consistent ^Prefix: Ensures reads see updates in order, with transactional updates visible as a consistent ^sequence.  
	  * Eventual: Updates in a transaction are applied together but may not be visible immediately due to eventual propagation across replicas.

	# Cosmos DB Consistency levels:
	  * Strong: Ensures all reads reflect the most recent committed writes, with transactional updates immediately visible together across all replicas.  
	  * Bounded Staleness: Reads lag behind writes by a set amount, but transactional updates are visible together within a defined lag.  
	  * Session: Guarantees transactional updates are visible together within a single client session.  
	  * Consistent Prefix: Ensures reads see updates in order, with transactional updates visible as a consistent sequence.  
	  * ^Eventual: Updates in a transaction are applied together but may not be visible immediately due to ^eventual propagation across replicas.

	# You are developing an application.
	  You need to set the standard HTTP properties of containers in Azure Blob Storage.
	  Which two HTTP properties can you set?
	  * ^Last - ^Modified
	  * ^ETag

	# You manage a multiregion deployment of an Azure Cosmos DB account named account1.
	  You need to configure the default consistency level for account1. The consistency level must maximize throughput and minimize latency for write operations.
	  Which consistency level should you use?

	  * ^eventual
	  * The ^eventual consistency level maximizes throughput and minimizes latency.

	# Azure Storage Account Features
	  * Configuring a ^legal ^hold policy on the container allows the documents to be protected from modifications or deletions until the hold is explicitly cleared.

	# You have blobs in an Azure storage account.
	  You need to implement a stored access policy that will apply to shared access signatures generated for the blobs.
	  To which type of storage resource should you associate the policy?

	  * The ^container that is hosting blobs is used for associating the corresponding stored access policies


~ Topic 3: Implement Azure security (20% to 25%)

	# You should be able to...IMPLEMENT USER AUTHENTICATION AND AUTHORIZATION
		* Authenticate and authorize users by using the Microsoft ^Identity platform
		* Authenticate and authorize users and apps by using Microsoft ^Entra ^ID
		* Create and implement ^shared ^access signatures
		* Implement solutions that interact with Microsoft ^Graph

	# You should be able to...IMPLEMENT SECURE AZURE SOLUTIONS
		* Secure app configuration data by using App ^Configuration or Azure ^Key ^Vault
		* Develop code that uses keys, secrets, and ^certificates stored in Azure Key Vault
		* Implement ^Managed ^Identities for Azure resources

	# Authorization vs Authentication
		* ^Authentication - confirm that users are who they say they are.

	# Authorization vs Authentication
		* ^Authorization - gives those users permission to access a resource.
		
	# When you register your application with Microsoft Entra ID, you're creating an identity configuration for your application that allows it to integrate with Microsoft Entra ID. 
	
		When you register an app in the Azure portal, you choose whether it is:
		* ^Single-^tenant: only accessible in your tenant
		* ^Multi-^tenant: accessible in other tenants
		
	# If you register an application in the portal...
		* ...an ^application object (the globally unique instance of the app) and a ^service ^principal object are automatically created in your home tenant
		
		* You also have a globally unique ID for your app (the app or ^client ID)
		
		* In the portal, you can then add secrets or certificates and scopes to make your app work, customize the branding of your app in the sign-in dialog, and more.
		
	# You can also create service principal objects in a tenant using 
		* Azure ^PowerShell
		* Azure ^CLI
		* Microsoft Graph
		* ...and other tools
		
	# A Microsoft Entra application is defined by its one and only application object. 
		* The application object resides in the Microsoft Entra ^tenant where the application was registered (known as the application's "home" ^tenant)
		
		* An application object is used as a template or blueprint to create one or more ^service ^principal objects
		
		* A service principal is created in every ^tenant where the application is used
		
		* Similar to a class in object-oriented programming, the application object has some ^static properties that are applied to all the created service principals (or application instances).
		
	# The "application object" describes three aspects of an application:
		* How the service can issue ^tokens in order to access the application
		* ^Resources that the application might need to access
		* The ^actions that the application can take

	# To access resources secured by a Microsoft Entra tenant, the entity that requires access must be represented by a security principal. 
		* This is true for both users (^user principal) and applications (^service principal).

	# The security principal defines the...
		* ... ^access policy and permissions for the user/application in the Microsoft Entra tenant.
		* This enables core features such as authentication of the user/application during sign-in, and authorization during resource access.

	# There are three types of SERVICE PRINCIPLES
		* Application Service Principle: this type of service principal is the local representation, or ^application ^instance of a global application object in a single ^tenant or directory
		
	# There are three types of SERVICE PRINCIPLES
		* ^Managed Identity: ^Managed identities provide an identity for applications to use when connecting to resources that support Microsoft Entra authentication
		
	# There are three types of SERVICE PRINCIPLES
		* ^Legacy: this type of service principal represents a ^legacy app
		* ^legacy apps are apps created before app registrations were introduced
		
	# Relationship between application objects and service principals
		* The application object is the ^global representation of your application for use across all tenants, and the service principal is the ^local representation for use in a specific tenant.
		
		* The application object serves as the ^template from which common and default properties are derived for use in creating corresponding service principal objects.
		
	# An application object has:
		* A one to ^one_ relationship with the software application
		* A one to ^many relationships with its corresponding service principal object(s).
		
	# The Microsoft identity platform implements the ... 
		* ^OAuth 2.0 authorization protocol
		* ^OAuth 2.0 is a method through which a third-party app can access web-hosted resources on behalf of a user. 
		* Any web-hosted resource that integrates with the Microsoft identity platform has a resource identifier, or *application ID URI. I.e. "https://graph.microsoft.com", "https://outlook.office.com", etc...
		
	# When a resource's functionality is chunked into small permission sets, third-party apps can be built to request only the permissions that they need to perform their function. Users and administrators can know what data the app can access.
		* In OAuth 2.0, these types of permission sets are called ^scopes. They're also often referred to as permissions. 
		* In the Microsoft identity platform, a permission is represented as a string value.
		
	# Authentication and Authorization: PERMISSION TYPES
		* ^delegated: used by apps that have a signed-in user present. For these apps, either the user or an administrator consents to the permissions that the app requests
		
		* ^app-^only access: used to run apps without a signed in user (i.e. background services or daemons). Only an administrator can consent to ^app-^only access permissions.
		
	# Authentication and Authorization: CONSENT TYPES
		* ^static user consent
		* ^incremental and dynamic user consent
		* ^admin consent
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Static ^user consent: You must specify all the permissions it would ever need up front (Difficult and often overwhelming to user)
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Incremental and Dynamic: Ability to requent permissions ^incrementally instead of all up front. You can ask for a minimum set of permissions upfront and request more over time as the customer uses more app features
		
	# Authentication and Authorization: CONSENT TYPES
		* ^Admin: ^Admin consent ensures that administrators have some other controls before authorizing apps or users to access highly privileged data from the organization.

	# Fill in the following AUTHENTICATION question:
		* The ^Conditional ^Access feature in Microsoft Entra ID offers one of several ways that you can use to secure your app and protect a service:
			- Multifactor authentication
			- Allowing only Intune (cloud-based service for managing mobile devices and computers) to access specific services
			- Restricting user locations and IP ranges

	# Components that make up the Microsoft identity platform:
		* ^OAuth 2.0 and ^OpenID Connect standard-compliant authentication service enabling developers to authenticate several identity types, including:
			- Work or school accounts, provisioned through Microsoft Entra ID
			- Personal Microsoft account, like Skype, Xbox, and Outlook.com
			- Social or local accounts, by using Azure Active Directory B2C
			- Social or local customer accounts, by using Microsoft Entra External ID

	# Components that make up the Microsoft identity platform:
		* ^Open-^source libraries: Microsoft Authentication Libraries (MSAL) and support for other standards-compliant libraries
		
		* Microsoft identity platform ^endpoint: works with a variety of standards-compliant libraries. It implements human readable scopes, in accordance with industry standards.
	
	# Components that make up the Microsoft identity platform:
		* Application ^management portal: A registration and configuration experience in the Azure portal, along with the other Azure management capabilities.
		
		* Application ^configuration API and PowerShell: Programmatic configuration of your applications through the Microsoft Graph API and PowerShell so you can automate your DevOps tasks.

	# Fill in the following AUTHENTICATION question:
		* A ^shared ^access ^signature (SAS) is a URI that grants restricted access rights to Azure Storage resources. 
		* You can provide a ^shared ^access ^signature to clients that you want to grant delegate access to certain storage account resources.

	# Types of Shared Access Signatures:
		Tip: A shared access signature (SAS) is a URI that grants restricted access rights to Azure Storage resources
		
		* ^User ^delegation SAS: secured with Microsoft Entra credentials and also by the permissions specified for the SAS. 
			- Applies to Blob storage only
			
		* ^Service SAS: 
			- secured with the storage account key. 
			- delegates access to a resource in the following Azure Storage services: Blob storage, Queue storage, Table storage, or Azure Files.
			
		* ^Account SAS: 
			- Secured with the storage account key. 
			- Delegates access to resources in one or more of the storage services. 
			- All of the operations available via the other SAS types are also available

	# When to use a Shared Access Signature (SAS)
		* When you want to provide secure access to resources in your ^storage account to any client who doesn't otherwise have permissions to those resources

	# Which tool or service is this?
		* Microsoft ^Graph is the gateway to data and intelligence in Microsoft 365. It provides a unified programmability model that you can use to access the tremendous amount of data in Microsoft 365, Windows 10, and Enterprise Mobility and includes  security features


	# Which tool or service is this?
		* The Microsoft ^identity ^platform for developers is a set of tools that includes authentication service, open-source libraries, and application management tools
		* Includes three types of service principals and how they relate to application objects
		* Includes permissions and user consent operate, and how conditional access impacts your application

	# Which tool or service is this?
		* The Microsoft ^identity ^platform helps you build applications your users and customers can sign in to using their Microsoft identities or social accounts, and provide authorized access to your own APIs or Microsoft APIs like Microsoft Graph.

	# Explore Service Principals:
		* When you register your application with Microsoft Entra ID, you're creating an identity configuration for your application that allows it to integrate with Microsoft Entra ID.
		* To delegate Identity and Access Management functions to Microsoft Entra ID, an application must be registered with a Microsoft Entra ^tenant.

	# When you register an app in the Azure portal, you choose whether it is:
		* ^Single tenant: only accessible in your tenant
		* ^Multi-tenant: accessible in other tenants

	# Explore Service Principals:
		* If you register an application in the portal, an application object (the globally unique instance of the app) and a service principal object are automatically created in your home ^tenant.
		* You also have a globally unique ID for your app (the app or ^client ID)

	# Application Object vs Service Principal
		* An application object is a ^global template of security configuration for an application registered on the Azure Portal
		* A service principal is a ^local representation of security configuration to a specific ^tenant (directory) registered on the Azure Portal

	# Application Object for an application registered on the Azure Portal describes:
		* 1.	How the service can issue ^tokens to access the application
		* 2.	^Resources the application might need to access
		* 3.	^Actions the application can take

		* Note: Application objects are the “templates” in which service principals are made. "Service Principals" are the copy of that template specific for a particular tenant.

	# Three types of Service Principals:
		* Application (service principal): A local copy of the applications Application Object specific to a particular tenant
		
		* Managed Identity (service principal): Enabling "Managed Identity" for your application will automatically create a Managed Identity service principal for your application. This co-exists alongside the application service principal for your application. Used for connecting your application to outside resources.
		
		* Legacy (service principal): Used to represent applications created before app registrations were introduced.
	
	# Access Resources on a Microsoft Entra tenant
		* To access resources secured by a Microsoft Entra tenant, the entity that requires access must be represented by a security principal. 
		* This is true for both ^users (^user principal) and ^applications (^service principal).

	# Microsoft Identity Platform Authorization
		* The Microsoft identity platform implements the ^OAuth 2.0 authorization protocol. 

	# Microsoft Identity Platform Authorization
		* Any web-hosted resource that integrates with the Microsoft identity platform has a resource identifier, or ^application ^ID URI.

	# Microsoft Identity Platform Authorization
		* When a resource's functionality is chunked into small permission sets, third-party apps can be built to request only the permissions that they need to perform their function. 
		
		* In OAuth 2.0, these types of permission sets are called ^scopes.
		* They're also often referred to as ^permissions.

	# Microsoft Identity Platform Authorization
		* In the Microsoft identity platform, a scope/permission is represented as a ^string value (data type).

	# Microsoft Identity Platform Permission Types
		* 1.	^Delegated Permissions:
			Used by apps that have a signed-in users
			The app is ^delegated the permission (aka represents the signed-in user) when it makes a call to the target resource

		* 2.	^App-^Only Access Permissions:
			Doesn’t represent a user. Instead, it represents a background service or daemon.
			Only an administrator can consent to ^app-^only access permissions.

	# Microsoft Identity Platform Consent Types
		* ^Static User Consent
			You specify up front all the permissions the user would ever need during the users login.
			User grants any permissions they haven’t consented to immediately on sign in

		* Incremental / Dynamic User Consent

		* Admin Consent


	# Microsoft Identity Platform Consent Types
		* Static User Consent

		* ^Incremental / Dynamic User Consent
			Only asks for a ^minimum set of permissions up front on user login, and request more overtime as the customer uses more features.
			Uses ^scopes to define each permission set for features
			Only applies to delegated permissions, and not to app-only access permissions

		* Admin Consent

	# Microsoft Identity Platform Consent Types
		* Static User Consent

		* Incremental / Dynamic User Consent

		* ^Admin Consent
			Provides administrators some control over authorizing apps or users to access highly privileged data
			Still requires the ^static permissions registered for the app

	# Microsoft Identity Platform Conditional Access
		* Conditional Access policies at their simplest are ^if-^then statements; ^if a user wants to access a resource, ^then they must complete an action

	# Microsoft Identity Platform Conditional Access
		* Common Signals
			* User or group membership (specific users and groups)

			* IP Location information
				* Trusted IP address ranges
				* Entire ^countries/regions IP ranges

			* Device

			* Application (attempting to access specific applications can trigger different Conditional Access policies)

			* Real-time and calculated risk detection (^risky users and sign-in behavior)

			* Microsoft Defender for Cloud Apps (sessions can be monitored and controlled in real time)

	
	# Managed Identities
		* Internally, managed identities are ^service ^principals of a special type, which are locked to only be used with Azure resources

	# What establishes the identity of a caller when accessing Azure Key Vault?
		* Authentication is done via Microsoft ^Entra ID.

	# Azure Key Vault Features
		* ^Soft ^delete is a feature in Azure Key Vault that allows recovery of deleted vaults and vault objects (such as keys, secrets, and certificates).

	# Azure Key Vault Features
		* Purge protection is an additional layer of protection that prevents the permanent deletion (purging) of ^soft ^deleted Key Vaults or vault objects, even by users with sufficient permissions, until the retention period expires.

	# Difference between Soft Deletes and Purges in Azure Key Vault
		* Soft deletes remove active objects, but not permanently. They can be recovered within the retention period
		* Purges are permanent deletes. You can only purge soft-deleted items. It's like emptying your recycling bin. 
		* Purge ^protection removes the ability to purge, and is off by default

	# Azure Key Vault Features
		* Azure Key Vault can be used as a ^Key Management solution. Azure Key Vault makes it easy to create and control the encryption ^keys used to encrypt your data.

	# What are the two service tiers available in Azure Key Vault, and what is a key difference between them?
		* Azure Key Vault has two service tiers: 
			* ^Standard tier, which encrypts with a software key
			* ^Premium tier, which includes hardware security module(HSM)-protected keys.

	# Which identity service is responsible for authenticating security principals when accessing Azure Key Vault?
		* Authentication with Key Vault works in conjunction with Microsoft ^Entra ID, which is responsible for authenticating the identity of any given security principal. 

	# The different kinds of security principals that interact with Azure Key Vault are:User: An individual with a profile in Microsoft Entra ID, representing a human user who can authenticate and access Key Vault resources.
		* ^Group: A set of users created in Microsoft Entra ID, allowing collective access management for Key Vault operations.
		* Service Principal: A security identity used by applications or services to access Key Vault, typically identified by an object ID and authenticated using a client secret or certificate.
		* Managed Identity: An automatically managed identity in Microsoft Entra ID, either system-assigned (tied to a specific Azure resource) or user-assigned (an independent Azure resource), used for secure access to Key Vault without managing credentials.

	# Which form of identity is recommended for applications authenticating to Azure Key Vault?
		* With a system-assigned ^managed identity for the application, Azure internally manages the application's service principal and automatically authenticates the application with other Azure services. 

	# What authorization mechanisms can be used to control access to data stored in an Azure Key Vault?
		* Authorization may be done via Azure ^role based access control (Azure RBAC) or Key Vault access policy. 
		  * Azure RBAC can be used for both management of the ^vaults and to access data stored in a vault
		  * Key vault access policy can only be used when attempting to access data stored in a vault. 

	# Which tool or service is this?
		* A ^managed identity is an identity that can be assigned to an Azure compute resource or any App hosting platform supported by Azure.
		* There are two types of ^managed identities: System-assigned and User-assigned.

	# Managed Identities
		* When you enable a ^system-assigned managed identity: 
			* A ^service principal of a special type is created in Microsoft Entra ID for the identity. 
			* The ^service principal is tied to the lifecycle of that Azure resource.

	# Managed Identities
		* ^User-assigned managed identities can be used by multiple resources. 
		* You authorize the managed identity to have access to one or more services.

	# How do ^Managed Identities authenticate to services? 
		* ^Managed identities provide an automatically managed identity in Microsoft Entra ID for applications to use when connecting to resources that support Microsoft Entra authentication. 




~ Topic 4: Monitor, troubleshoot, and optimize Azure solutions (15% to 20%)

	# You should be able to...IMPLEMENT CACHING FOR SOLUTIONS
		* Configure cache and ^expiration policies for Azure Cache for Redis
		* Implement secure and optimized application cache ^patterns including data sizing, connections, encryption, and expiration
		* Implement Azure ^Content ^Delivery ^Network endpoints and profiles

	# You should be able to...TROUBLESHOOT SOLUTIONS BY USING APPLICATION INSIGHTS
		* Configure an app or service to use Application Insights
		* Monitor and analyze metrics, logs, and ^traces
		* Implement Application Insights ^web ^tests and ^alerts


	# You can utilize Redis on your own machine as a service or on the cloud. 
		* The default port used for redis is port ^6379

	# Redis is not used for long term storage...
		* All data in Redis exists in ^memory

	# Redis has a very simple structure
		* Uses ^json format
		* I.e. uses "Key": "Value" pairs
		
	# Which tool can you use to interact with a Redis Cache instance manually?
		* The ^redis-cli allows you to enter commands and interact with a Redis Cache instance manually

	# Which Redis command sets a key called "points" to the value "12"?
		* ^SET points 12
		
	# What does the following Redis command do? 
		"lrange MyList 0 -1"
		* This command returns ALL of values of the ^list called MyList
	
	# Explain the following Redis command:
		"setex MyPassword 2400 dwarfFortress12$"
		* This command sets the ^key called MyPassword and it's ^value to dwarfFortress12$. 
		* Then, that keyvalue pair will ^expire after 2400 ^seconds
	
	# Which command in Redis is responsible for checking to see if a keyvalue pair exists?
		* "^EXISTS myKey"
		
	# Microsoft recommends using the following pattern when working with caches like Redis Cache
		* The ^Cache-^Aside pattern
		
	#  Storing too much in a cookie can have a negative effect on performance as the cookie size grows and is passed and validated with every request.
		* A typical solution uses the ^cookie as a KEY to query the data in a database
		* Using an ^in-^memory cache, like Azure Cache for Redis, to associate information with a user is faster than interacting with a full relational database.
		* This is often called the Session Store pattern

	# Applications sometimes require a series of commands against a backend data-store to execute as a single atomic operation
		* Single atomic operation means that all commands MUST succeed, or all must be rolled back to the initial state
		* Azure Cache for Redis supports executing a ^batch of commands as a single transaction
		
	# Basic tier for Redis cache runs on a single VM. 
		* This tier has no ^service-^level ^agreement and is ideal for development/test and noncritical workloads
		
	# In general, when choosing Redis Cache tiers, The higher up the tiers you go you get access to higher ^throughput, lower ^latency, better ^availability and more ^features
		
	# Fill in the following:
		* A ^content ^delivery ^network is a distributed network of servers that can efficiently deliver web content to users
		* They store cached content on edge servers in ^point-of-^presence (POP) locations that are close to end users, to minimize latency.
		
	# Features of Azure CDN (Content Delivery Networks):
		* Large scaling, less traffic to origin servers
		* CDN ^Caching rules
		* ^HTTPS support: Azure CDN can host a TLS/SSL certification or you can use your own. 
			Note: Using ^HTTPS does not increase the cost of Azure CDN.
		* Azure diagnostics logs
		* File compression / object ^chunking
		
	# Features of Azure CDN (Content Delivery Networks):
		* Geo-^filtering enables you to allow or block content in specific countries/regions.
		* Azure CDN can also accelerate dynamic content, which can't be cached, by using various network optimizations using CDN POPs.
		* Pre-populate caching in CDNs by using “ az cdn endpoint ^load ”
		* Purge content from your CDNs by using “” or using the PurgeContent method in the Microsoft.Azure.Management.Cdn library in an app implementation.

	# How Azure CDN Functions
		* 1. User requests endpoint, DNS routes request to closest ^POP location
		* 2. If no edge servers have the requested content in their cache, ^POP requests the file from the ^origin server.
				 Note: “^origin server” here can mean an Azure Web App, or any publicly accessible web server.
		* 3. Origin server returns file to edge server in ^POP location
		* 4. Edge server in ^POP location caches file and returns it to user. ^Time-to-^live (TTL) is specified by the origin server in the HTTP header (Cache-Control), or default to 7 days.

	# When setting Caching Rules, Azure CDN's support two kinds of match conditions:
		* ^Path match condition: This condition matches the path of the URL, excluding domain name, and supports the wildcard symbol
			For example, /myfile.html, /my/folder/*, and /my/images/*.jpg
		
		* ^Extension
		match condition: Provide a list of comma delimited file extensions to match.
			For example, .jpg, .mp3, .png

	# Azure CDN Caching Rules Priority:
		* If no rules are defined, the ^default caching behavior is used (HTTP cache-directive header)
		* If ^global caching rules exist, they overwrite any default caching behavior
		* If ^custom caching rules exist, they overwrite any other behavior

	# "Fresh" content (Azure CDN concepts)
		*  A cached resource is considered to be fresh when its age is less than the that defined by a cache setting
		* Therefore if your content is time-sensitive and you need to ensure accurate updates to the content, then make sure to set your ^time-to-^live to a short duration, or consider including a version string in the asset URL.

	# Azure CDNs (Content Delivery Networks) Use Object Chunking
		* When a ^large file is requested, the CDN prefetches smaller 8MB chunks of the content in parallel, serving the user the chunks as they are recieved and caching those chunks for repeated requests.
		* This prefetch process ensures that the content stays one chunk ahead of the user, which reduces latency. 

	# Collections of Azure CDN (Content Delivery Network) endpoints is called:
		* A CDN ^profile
		* A ^profile defines the pricing tier for that collection of endpoints
		* You can only have so many ^profiles in one azure subscription

	# What is the primary function of ^Application ^Insights? 
		* ^Application ^Insights is an extensible Application Performance Management (APM) service for developers and DevOps professionals to monitor live applications.  

	# What is the role of the ^Instrumentation ^Key in Application Insights? 
		* The ^Instrumentation ^Key uniquely identifies an Application Insights resource and is used to send telemetry data from an application to the correct resource in Azure.  

	# What is the benefit of using ^Live ^Metrics in Application Insights? 
		* ^Live ^Metrics provides a near real-time view of application performance, allowing developers to observe metrics and failures as they happen.  

	# A development team is using Application Insights to monitor their web application deployed on Azure. 
	  They have noticed discrepancies in the reported metrics due to high telemetry volume.
	  You need to ensure that the reported metrics accurately reflect the application's performance without being affected by telemetry sampling.

	  What should you implement to achieve this goal?

	  * Configure Application Insights to use ^preaggregated standard metrics for dashboarding and real-time alerting.

	# Application Insights
	  * ^Preaggregated standard metrics are not affected by telemetry sampling and provide accurate real-time data, which makes them suitable for dashboarding and alerting.

	# Application Insights
	  * Unlike raw telemetry data (e.g., individual request or event logs), ^preaggregated metrics are processed and aggregated on the server side before being stored, making them more efficient for querying and visualization. These metrics are designed to give you quick insights into your application’s health without the overhead of processing large volumes of raw telemetry data.

	# An e-commerce platform is planning to expand its services globally. The platform is hosted on Azure and utilizes various Azure services and third-party integrations.
	  You need to design and create a robust monitoring solution that can scale with the expansion and provide insights into the performance of the platform across different regions.
	  What should you do?

	  * Deploy ^multiple Application Insights instances for each region and use Azure Monitor to aggregate the data.



~ Topic 5: Connect to and consume Azure services and third-party services (15% to 20%)

	# You should be able to...IMPLEMENT API MANAGEMENT
		* Create an Azure API Management instance
		* Create and ^document APIs
		* Configure access to APIs
		* Implement ^policies for APIs

	# You should be able to...DEVELOP EVENT-BASED SOLUTIONS
		* Implement solutions that use Azure Event ^Grid
		* Implement solutions that use Azure Event ^Hub

	# You should be able to...DEVELOP MESSAGE-BASED SOLUTIONS
		* Implement solutions that use Azure ^Service ^Bus
		* Implement solutions that use Azure ^Queue ^Storage queues
		
		
	# Which service is this?
		* Azure ^Event ^Grid is a serverless event broker you can use to integrate applications using events.
		
	# Benefits of using Azure Event Grid:
		* Simplify event consumption
		
		* Lower costs by eliminating the need for constant polling
		
		* Efficiently and reliably routes events from Azure as well as non-Azure resources and distributes the events to registered subscriber endpoints
		
	# Which tool or service is this?
        *  Azure ^API ^Management provides a centralized API gateway that enables customers to publish APIs to internal and external developers, and to monitor and protect them at scale.

	# Azure API Management
        * Azure API Management provides four key components: the ^API ^gateway, the ^management plane, the developer ^portal, and analytics.

	# Azure API Management
        * The API ^gateway is the client-facing component of API Management that accepts ^API calls and routes them to the backend services.

	# Azure API Management
        * The ^management plane in Azure API Management provides a web-based user interface for managing APIs and ^users.

	# Azure API Management
        * The ^developer ^portal in Azure API Management is a website that enables API consumers to learn about and try the APIs.

	# Which tool or service is this?
		* Azure ^Event ^Grid is a fully managed event routing service that simplifies event-based app development by connecting event sources with event handlers.

	# Which tool or service is this?
		* Azure ^Event ^Grid enables reactive programming using a publish-subscribe model to route ^events from sources to handlers.

	# Azure Event Grid
		*  An ^event in Azure Event Grid is a lightweight notification of a condition or state change, containing details like source, type, and time.

	# Azure Event Grid
		* Azure Event Grid uses ^topics to organize and categorize events, allowing subscribers to receive only relevant notifications.

	# Azure Event Grid
		* A ^subscription in Azure Event Grid defines which events from a topic are routed to a specific handler or endpoint.

	# Microservices Architecture and Events
	  * Microservices thrive on loose coupling, where services communicate without direct dependencies. 
	  * ^Event ^Hubs acts as a centralized message broker that ingests massive volumes of events (think telemetry data, logs, or user actions) and distributes them to multiple consumers (your microservices).
	  * Each microservice can subscribe to the event stream (via ^consumer ^groups) and process only the events it cares about, without needing to know who produced the events.

	# Event Hubs Retention
	  * Events are stored in Event Hubs for a configurable retention period (up to 7 days by default, or longer with features like Event Hubs Capture). 
	  * This ensures microservices can catch up if they go offline temporarily, supporting independent deployability with ease.
	  * It also supports ^at - ^least - ^once delivery, which is critical for microservices that need to ensure no event is missed, even if a service crashes or is redeployed.

	# Microservices Architecture and Event Hub
	  * Each microservice can have its own ^consumer ^group, which is like a dedicated view of the event stream. 
	  * This means Service A (e.g., logging) and Service B (e.g., analytics) can read the same events independently at their own pace, without interfering with each other. 
	  * This is key in microservices, where different services have different processing needs.

	# Differences Between Event Hub and Event Grid
	  * Event Grid, while great for event-driven architectures, isn’t optimized for the same ^high - ^throughput streaming scenarios as Event Hubs.

	# Differences Between Event Hub and Event Grid
	  * Event Grid uses a ^push - based model, where events are immediately routed to ^subscribers (e.g., Azure Functions, Logic Apps, or webhooks) based on event types. This is great for reactive, low-volume scenarios (e.g., responding to a file upload in Blob Storage).
	  * Microservices often need a ^pull - based model, where they can control how and when they process events, especially at scale. Event Hubs supports this by storing events in a stream that services can read at their own pace.

	# Differences Between Event Hub and Event Grid
	  * Event ^Grid is designed for low-latency, discrete events (e.g., a single “order placed” event triggering a workflow).
	  * Event ^Hubs on the other hand, is engineered for massive event ingestion—think millions of events per second from thousands of producers, which is common in microservices handling telemetry or transactional data.

	# Differences Between Event Hub and Event Grid
	  * Event ^Hubs retains events, allowing microservices to catch up later, which is critical for independent scaling and deployment.
	  * Event ^Grid doesn’t store events; it routes them immediately and forgets them. If a microservice is offline or slow, it might miss events, which breaks the decoupled, resilient nature of microservices.

	# Event Hub
		* Namespaces, Event Hubs, and Partitions: Understand how ^namespaces group Event Hubs, and how ^partitions enable parallel processing.
		* Consumer Groups: Know how they allow multiple services to read the same stream independently.
		* Event Hubs Capture: Saves events to Blob Storage or Data Lake for long-term storage or replay.
		* Throughput Units (TUs): Control scalability and cost; auto-inflate can dynamically adjust TUs.
		* SDK Usage: Be familiar with sending and receiving events using the .NET SDK (e.g., EventHubProducerClient and EventProcessorClient).
		* Comparison with Event Grid: Event Hubs is for high-throughput streaming; Event Grid is for reactive, event-driven routing.

	# Event Hub
		* Namespaces, Event Hubs, and Partitions: Understand how namespaces group Event Hubs, and how partitions enable parallel processing.
		* ^Consumer ^Groups: Know how they allow multiple services to read the same stream independently.
		* Event Hubs Capture: Saves events to Blob Storage or Data Lake for long-term storage or replay.
		* Throughput Units (TUs): Control scalability and cost; auto-inflate can dynamically adjust TUs.
		* SDK Usage: Be familiar with sending and receiving events using the .NET SDK (e.g., EventHubProducerClient and EventProcessorClient).
		* Comparison with Event Grid: Event Hubs is for high-throughput streaming; Event Grid is for reactive, event-driven routing.

	# Event Hub
		* Namespaces, Event Hubs, and Partitions: Understand how namespaces group Event Hubs, and how partitions enable parallel processing.
		* Consumer Groups: Know how they allow multiple services to read the same stream independently.
		* Event Hubs Capture: Saves events to Blob Storage or Data Lake for long-term storage or replay.
		* Throughput Units (TUs): Control scalability and cost; auto-inflate can dynamically adjust TUs.
		* SDK Usage: Be familiar with sending and receiving events using the .NET SDK (e.g., EventHubProducerClient and ^EventProcessorClient).
		* Comparison with Event Grid: Event Hubs is for high-throughput streaming; Event Grid is for reactive, event-driven routing.















	